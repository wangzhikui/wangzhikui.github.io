<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王智魁Allen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wushuning.com/"/>
  <updated>2018-10-29T06:13:19.342Z</updated>
  <id>http://wushuning.com/</id>
  
  <author>
    <name>王智魁Allen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>敏捷开发方法(三) 看板 vs scrum</title>
    <link href="http://wushuning.com/2018/10/29/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-3-scrum%E5%AF%B9%E6%AF%94kanban/"/>
    <id>http://wushuning.com/2018/10/29/敏捷开发方法-3-scrum对比kanban/</id>
    <published>2018-10-28T16:00:00.000Z</published>
    <updated>2018-10-29T06:13:19.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scrum-与-Kanban-对比-amp-选择"><a href="#Scrum-与-Kanban-对比-amp-选择" class="headerlink" title="Scrum 与 Kanban 对比&amp;选择"></a>Scrum 与 Kanban 对比&amp;选择</h1><p><img src="/images/敏捷/kanban-scrum.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scrum-与-Kanban-对比-amp-选择&quot;&gt;&lt;a href=&quot;#Scrum-与-Kanban-对比-amp-选择&quot; class=&quot;headerlink&quot; title=&quot;Scrum 与 Kanban 对比&amp;amp;选择&quot;&gt;&lt;/a&gt;Scrum 与 Kanban
      
    
    </summary>
    
      <category term="研发管理" scheme="http://wushuning.com/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="笔记" scheme="http://wushuning.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="研发管理" scheme="http://wushuning.com/tags/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发方法(二) 看板</title>
    <link href="http://wushuning.com/2018/10/29/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-2-kanban/"/>
    <id>http://wushuning.com/2018/10/29/敏捷开发方法-2-kanban/</id>
    <published>2018-10-28T16:00:00.000Z</published>
    <updated>2018-10-29T06:08:34.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h2><ul><li>关注可视化和管理流程</li><li>不依赖迭代，提倡持续连续工作流，使得团队保持专注</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><strong>四个主要原则：</strong></p><ul><li>从实际开始；专注增量和渐进性改进</li><li>尊重现有方法和角色，培养组织各级领导力</li></ul><p><strong>六个核心实践：</strong></p><ul><li>可视化工作流程</li><li>在制品数量（WIP）</li><li>工作项流动</li><li>明确规则</li><li>确保反馈</li></ul><h1 id="建立看板"><a href="#建立看板" class="headerlink" title="建立看板"></a>建立看板</h1><h2 id="可视化工作流"><a href="#可视化工作流" class="headerlink" title="可视化工作流"></a>可视化工作流</h2><ul><li>绘制价值流图：依据团队实际流程，可视化全过程，并通过与上下游协作部门达成共识，进行价值流图向上下游的扩展；</li><li>设置输入和输出边界：在设计看板系统的时候要尽早对在制品控制的边界做出决策，对受控范围内的自身团队的工作提供透明度；</li><li>分割进行中和已完成，添加必要的缓冲区或等待队列：缓冲或等待队列增大了系统的在制品值，他们将导致前置时间拉长；但是缓冲和队列可以使工作流动变得平滑；</li><li>可视化工作项：<ul><li>可视化价值：上图中的每一个卡片代表一个价值项，它们可以是功能特征、技术任务、缺陷、重构、环境相关等等以开发为中心的一切工作类型；</li><li>可视化价值流动：任务卡片所在的列，表示其所处的阶段，价值流是价值项从左至右的流动过程，是信息的产出过程，也是价值增加的过程；</li><li>可视化问题及阻碍：价值流动可能会被阻碍，标识阻碍因素（例如用红色卡片对问题和阻碍因素可视化）并推动其解决，促进价值流动；</li><li>可视化队列/瓶颈：最终限制系统端到端流量的是系统瓶颈处的流量，必须从解决瓶颈问题开始；<br><img src="/images/敏捷/看板工作流.png" alt=""></li></ul></li></ul><h2 id="显示化规则"><a href="#显示化规则" class="headerlink" title="显示化规则"></a>显示化规则</h2><p>团队看板系统建立之初，一项有价值的实践必不可少，显示化团队工作的规范，规则。显示化流程规则，是指明确定义和沟通团队所遵循的流程规则，从而让团队和利益干系人就工作协议达成一致。</p><p>价值项的“流转规则”是看板系统中最典型流程规则，它定义了一个价值项从一个阶段进入下一阶段所必须达到的标准。</p><p><img src="/images/敏捷/显示规则.png" alt=""><br>图中，给出了某团队其中价值流转规则的实例，例如流程规则2定义了从UE设计阶段进入待开发开发阶段所必须达到的条件。“流转规则”的显式化，让质量内建于各个阶段——这与精益制造中内建质量的思想是一致的。某些团队使用DoD（定义完成标准）做流转规则不失为定义“流程规则”的简便方法，但应该注意的是流程规则可能需要随着团队和流程改进调整。</p><p>除“流转规则”外，其它重要的规则也可以或者需要被显式化，如，团队的工作纪律，协作规则、优先级的定义规则，缺陷处理策略，输入节奏，交付节奏等，我们称之为其他规则。</p><p>“流程规则”和“其他规则”可以让研发相关活动有序保质的完成。</p><h2 id="初始化在制品限额-WIP）"><a href="#初始化在制品限额-WIP）" class="headerlink" title="初始化在制品限额(WIP）"></a>初始化在制品限额(WIP）</h2><ul><li>在制品限额:  明确限制流程中每个状态上最多同时进行的任务数，是看板方法中的一个核心机制，如下图所示，列标题上面的数字标识了该阶段允许的在制品的最大数目；</li><li>设置在制品限额的目的：<ul><li>优化价值流动：限制在制品数量，减少了价值项在阶段间的排队等待，缩短了价值从进入系统到交付的时间，加速了端到端的价值流动；</li><li>暴露问题：限制在制品数量，让过去被隐藏的问题，如团队协作不良、需求定义错误、开发环境低效、资源分配不均衡等得以显现；</li></ul></li><li>初始化在制品限额：<ul><li>工作任务的在制品限额应该按照每个人、每个开发结对或每个协同工作的小团队的平均工作项数量来设置，一般而言，限额数值应该控制在1~3人（/结对/团队）范围内比较合适，业内推荐限额设置公式为 2n-1（n为人数/结对数/小团队数）；</li><li>可以将工作任务一栏和完成队列归在一起，合并计算在制品限额；缓冲区的限额越小越好，但是其大小要确保瓶颈资源得到充分利用，并足以维系系统中的稳定流动；</li><li>无需浪费时间试图设定一个完美的在制品限额大小，初始化之后，需要在使用过程中不断的试验进行调整；</li></ul></li><li>在制品限制形成的拉动机制：在制品数目小于在制品限额时，才可以从前一阶段拉入新的工作。上图中，开发阶段的在制品限制数目是14，而实际在制品数目是6，可以拉入新的工作；需求验证阶段的在制品数是3，达到了上限，就不允许拉入新工作</li></ul><h2 id="创建物理看板"><a href="#创建物理看板" class="headerlink" title="创建物理看板"></a>创建物理看板</h2><p><img src="/images/敏捷/物理看板1.png" alt=""><br><img src="/images/敏捷/物理看板2.png" alt=""></p><h1 id="使用看板"><a href="#使用看板" class="headerlink" title="使用看板"></a>使用看板</h1><h2 id="使用看板进行协调"><a href="#使用看板进行协调" class="headerlink" title="使用看板进行协调"></a>使用看板进行协调</h2><h3 id="可视化控制和拉动"><a href="#可视化控制和拉动" class="headerlink" title="可视化控制和拉动"></a>可视化控制和拉动</h3><ul><li>首先，在制品限额。即我们看到的每一个栏目上标示的限制数字。我们要控制在那个栏目下区域卡片的数量，不能超过在制品限额的数量。例如图四中UE（2）栏目的在制品限额=2，当前没有卡片在那个区域，我们可以从输入列中拉入2张卡片到UE栏目，并开始UE设计工作。 </li><li>其次，拉动策略。当我们要从输入列中拉入卡片时候，需要根据拉动策略，如工作项类型，到期日，工作项在队列中停留的时间，以及优先级选择合适的卡片到UE栏目。拉动并不是随便拉动，需要根据拉动策略选择工作项。 </li><li>最后，工作项受阻和延期。根据进入队列的时间和实际日期对比，可以判断出某个工作项是否长期滞留或者受阻。一旦工作项受阻，需要将受阻问题卡片黏贴到这个工作项上以作标示。受阻问题卡片常见表现为，前置工作项卡片，管理问题卡片，或者缺陷卡片。团队需要优先排除受阻问题。让受阻工作项流动起来。</li></ul><h3 id="每日站立会"><a href="#每日站立会" class="headerlink" title="每日站立会"></a>每日站立会</h3><ul><li>每日站立会是看板管理中的一项活动，聚焦在工作项的流动性问题的协调和解决。会议的组织者一般是项目经理或产品经理，参与人员为一为包括，业务，需求，设计，测试和看板上参与价值流产生和传递的干系人。 </li><li>站立会的步骤一般是组织者先进行看板的走读。所谓看板的走读，即从后往前，从右到左逐一检查栏目下空间的工作项卡片，主要关注在制品限额是否已经到达上限和受阻和延期的工作项。组织者针对看板的受控项提出问题。然后团队成员简短讨论产生问题的原因，解决方案，并承诺何时可以解决该问题。另外，针对影响流动的其他并未在看板上展示出来的问题组织需要相关人员会后讨论，并协助最终把问题解决。</li><li>这种关注流动性问题的站立会，可以让更多人参与进来，同时不会导致会议时间持续过长，我们建议站立会大约15分钟左右。</li><li>另外，看板每日站立会来源与Scrum敏捷开发过程中的每日站立会，由于看板上关注了价值流转换中每个人的具体的工作项，每个工作项都可以看到当前的负责人，所以不必再让每个人讲述，昨天做什么，今天计划做什么，遇到了什么障碍类似的问题。需要特别注意的是工作项卡片上必须标示了当前工作项的负责人</li></ul><h3 id="调整在制品限额"><a href="#调整在制品限额" class="headerlink" title="调整在制品限额"></a>调整在制品限额</h3><ul><li>如果一开始将在制品限额设定得过低，这时候团队可能会发现，在看板墙上可以看见大量代表问题的阻碍项，过小的在制品限额意味着几乎每一件事情都会变得举步维艰，许多人会无事可做而处于空闲状态；例如：开发队列的在制品限额我们设定为4，但是我们有5个开发人员，这样的在制品限额就有可能造成开发人员的产能剩余，工作闲置； </li><li>相反的，如果在制品限额设定得太高，那就不能起到在制品限额的可视化问题及预警作用，可能直到问题失控才会引起大家的重视； 例如，下图中开发队列的在制品限额我们一开始设定过高（14），开发的队列不断输入，过了一段时间之后，我们会发现过多的开发造成了等待队列的大量堆积，整个看板系统的流通遇到瓶颈，在这种状况出现之前，我们就应该通过合理的在制品限额来暴露问题 </li><li>对于能力比较强且有较高成熟度的组织，由于预期之外的问题很少，所以可以考虑采用约束较为严格的在制品限制规则，对于成熟度较低的组织，把在制品的限制规则设得比较宽松为好，开始时，设得大一些，通过创建持续改进的驱动力，将其逐步调低，所有的在制品限额都需要通过看板系统不断的试验进行调整； </li><li>在有了相对合适的在制品限额后，可能会有一些意想不到的变异性因素会导致上游步骤变成一个临时瓶颈，看板系统在该处的在制品限额会让整个工作流停下来解决该处的瓶颈，避免系统产生赌塞和过载，当障碍被排除时，系统便可重新恢复流动；</li></ul><h2 id="建立交付节奏"><a href="#建立交付节奏" class="headerlink" title="建立交付节奏"></a>建立交付节奏</h2><p>交付节奏是指以固定频率交付可用软件的模式。稳定交付节奏十分重要，定期交付有利于建立信任，缺乏可预测性会破坏信任。同时能够引导团队能够围绕交付目标开展工作，并降低了每次交付的协调成本，提高工作效率。</p><p>Scrum使用固定时间盒sprint来获得稳定的节奏，一般1-4周。迭代开始时候，确定代办项，然后开始一系列的分析，设计，开发，测试，重构等活动，这些活动都要基于假设代办项粒度足够小，并假设上述一系列活动都可以在时间盒内完成。</p><p>看板方法抛弃了固定时间和概念，把优先级排序，开发，交付等活动分离开来，分别对待这些活动，允许每种活动根据自身特性来调整节奏。同时看板方法更倾于更频繁的交付节奏，甚至可以支撑随需或者临时交付。</p><p>看板对于交付节奏的处理，主要把创建故事或需求条目的时间点与交付频率分离开。当准备交付时，其他工作仍然处于进行中状态。即输入节奏和交付节奏分离。好处显而易见，由于故事优先级排序活动参与人与交付活动参与人可能有不同，协调活动也不一样，按照各自的节奏和方式工作效率更高。</p><p>确定交付节奏并非一件容易的事，交付需要付出协调成本和事务成本，同时要考虑带来的市场价值。频发发布可以降低市场风险但会增加发布成本。假设50人团队，一次发布需要抽出10人投入3天来完成一次代码的交付，那么2周一次发布频率可能带来的成本较高。所以选择怎样的发布频率要根据实际情况来定义。</p><p>看板使用过程中，会逐渐形成适合团队的发布频率，也要不断提升效率提升交付节奏。</p><h2 id="建立输入节奏"><a href="#建立输入节奏" class="headerlink" title="建立输入节奏"></a>建立输入节奏</h2><ul><li>输入节奏：与参会干系人达成共识的定期召开会议的时间间隔，会议中按照优先级来选择代办请求项，填充到持续工程的输入队列中以便开发，通常我们也把这种活动叫做优先级排序节奏；</li><li>确定优先级排序节奏：节奏固定的优先级排序：通过与参加优先级排序决策的所有干系人达成一致的以合适的频率定期召开会议，建立优先级排序节奏；一般的建议是，这种会议越频繁越好，这样，输入队列就会越小，从而使系统中的浪费越少，在制品越少，前置时间越短，与此相关的成员和组织间就会更频繁的开展协作；要努力寻找开销最小且最为有效的可能的协调方案，合理情况下，越频繁举行的优先级排序会议越好；</li><li>随需或临时性的优先级排序：以固定频率定期召开优先级排序会使事物成本及协调成本逐步降低，而对于会议的效率和节奏都很高的高成熟度组织，可以选择随需或者临时进行的优先级排序；</li></ul><h1 id="度量看板"><a href="#度量看板" class="headerlink" title="度量看板"></a>度量看板</h1><h2 id="度量和管理工作流"><a href="#度量和管理工作流" class="headerlink" title="度量和管理工作流"></a>度量和管理工作流</h2><p>看板系统是可预测的，专注于保持系统的顺畅流动。物理看板可以提供基本的度量数据，包括在制品数量，前置时间等，同时可基于累积流图进行分析和障碍的解决。电子看板为管理提供了更多的度量数据，为团队的管理和报告提供支撑。</p><h2 id="度量元"><a href="#度量元" class="headerlink" title="度量元"></a>度量元</h2><p><img src="/images/敏捷/度量元.png" alt=""></p><h2 id="度量方法"><a href="#度量方法" class="headerlink" title="度量方法"></a>度量方法</h2><h3 id="累积流图"><a href="#累积流图" class="headerlink" title="累积流图"></a>累积流图</h3><p><img src="/images/敏捷/累积流量图1.png" alt=""><br><img src="/images/敏捷/累积流量图2.png" alt=""></p><ul><li>左面的斜线是累积已经开始的价值项（如用户需求）数目；</li><li>右面斜线是累积完成价值项的数目；</li><li>两条斜线的垂直距离表示某个时刻已经开始但还没有完成的价值项数目，也就是在制品数量；</li><li>两条斜线的水平间距表示价值项从开始到完成的平均前置时间，也就是从概念到交付的响应时间，它是价值流动效率的一个重要衡量；</li><li>在制品数量与周期时间成线性关系：在制品数量减少，带来平均前置时间缩短，即流量速率的提升；</li><li>斜线的斜率反应的是价值流量速率，也就是每周（或固定时间段内）可以交付的价值项数量，这里的价值可以是故事点数、功能点数等等，团队或组织的目标是要持续提升交付速率；</li><li>可以识别工作中的瓶颈：在开发的流程中，我们可以将其中每个不同环节（分析、实现、测试、部署、完成）的工作项数量用不同*颜色的带状区域可视化出来，观察一下，是否有一个区域的在变窄，同时在流程中相对于这个环节之前的环节正在变宽（说明队列正在增长，如下两图示例），如果我们看到了这种情况，我们就在吞吐量最低的地方找到了瓶颈，着手去解决它。</li></ul><h3 id="准时交付率"><a href="#准时交付率" class="headerlink" title="准时交付率"></a>准时交付率</h3><p>通过将预估前置时间和实际前置时间进行对比，展示的是团队的可预测水平，度量一个工作项是否能够如期或者提前交付，估算的准确性是表明系统是否高效运行的一个信息指示器；我们也可以通过度量最近月份以及年度的准时交付率，来判断团队交付能力趋势的提升</p><h3 id="初始质量"><a href="#初始质量" class="headerlink" title="初始质量"></a>初始质量</h3><p>缺陷意味着成本，它会影响看板系统的周期时间和流量速率，度量缺陷与在制品总量和流量速率的趋势是有意义的，我们期望看到缺陷率越来越低，同时周期时间和流量速率不断提升<br><img src="/images/敏捷/初始质量.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;重点关注&quot;&gt;&lt;a href=&quot;#重点关注&quot; class=&quot;headerlink&quot; title=&quot;重点关注&quot;&gt;&lt;/a&gt;重点关注&lt;/h
      
    
    </summary>
    
      <category term="研发管理" scheme="http://wushuning.com/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="笔记" scheme="http://wushuning.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="研发管理" scheme="http://wushuning.com/tags/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发方法(一) Scrum</title>
    <link href="http://wushuning.com/2018/10/26/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-1-scrum/"/>
    <id>http://wushuning.com/2018/10/26/敏捷开发方法-1-scrum/</id>
    <published>2018-10-25T16:00:00.000Z</published>
    <updated>2018-10-26T09:04:03.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scrum团队-三大角色"><a href="#Scrum团队-三大角色" class="headerlink" title="Scrum团队-三大角色"></a>Scrum团队-三大角色</h1><p>Scrum团队：由产品负责人、开发团队和Scrum Master组成。</p><ul><li>是跨职能的自组织团队</li><li>自组织团队自己选择如何最好地完成工作，而不是由团队外的人指导</li><li>跨职能团队拥有完成工作所需要的全部技能，不需要依赖团队以外的人</li><li>这种团队模式的目的是最大限度地优化灵活度、创造力和生产效率</li></ul><p>三大角色：<br><img src="/images/敏捷/scrum三大角色.png" alt=""></p><h1 id="Scrum管理-五事件"><a href="#Scrum管理-五事件" class="headerlink" title="Scrum管理-五事件"></a>Scrum管理-五事件</h1><p>Scrum 管理:</p><ul><li>所有事件是有时间盒限定的</li><li>每个事件都有时间限制的</li><li>一旦Sprint开始，它的周期也就固定下来了，不能缩短或者延长</li></ul><p>Scrum 管理五事件包括： </p><ol><li>Sprint</li><li>计划会议</li><li>站立会议</li><li>回顾会议</li><li>演示会议</li></ol><p><img src="/images/敏捷/scrum管理五事件.png" alt=""></p><h2 id="Scrum管理实施步骤指南（1）-Sprint-回顾会议"><a href="#Scrum管理实施步骤指南（1）-Sprint-回顾会议" class="headerlink" title="Scrum管理实施步骤指南（1）  Sprint 回顾会议"></a>Scrum管理实施步骤指南（1）  Sprint 回顾会议</h2><h3 id="会议准备"><a href="#会议准备" class="headerlink" title="会议准备"></a>会议准备</h3><ul><li>会议物品：白板、便签纸、笔等；</li><li>会议资料：通常有《Sprint任务清单》《站立会议问题跟踪表》、《Sprint验证问题一览表》、《燃尽图》</li><li>参会人员：PO、SM、Team、敏捷教练；</li><li>会议组织：可由SM，或敏捷教练，或任一团队成员组织。</li><li>会议氛围：愉悦的环境，如：可采用简易茶话会的形式，促进团队成员轻松打开话题，畅所欲言，也可促进团队成员放下手中的其他工作，把思路带到会议中</li></ul><h3 id="会议过程"><a href="#会议过程" class="headerlink" title="会议过程"></a>会议过程</h3><ul><li>会议组织者介绍会议目标及会议进程。明确会议规则：回顾会要求每个人都参与，做完一个迭代肯定有感受的，调动大家进行坦诚交流。 </li><li>上一迭代回顾：将站会问题一览表、燃尽图、验证问题一览表等的问题进行整理回顾，哪些做了，哪些没有完成，遇到了哪些问题。 </li><li>团队总结：团队成员根据上述展现的情况及自身感受，在便签纸上分别写出认为上一迭代团队或个人做的“好的”及“可改进的”两类意见，两方面各写一条。注意‘可改进’的问题最好写能够改进的。之后由大家逐一讲解便签条内容，并贴到白板相应的一列上。这里要求每个人都要写下来，避免说过就忘了。 </li><li>确定改进项：团队成员针对每一位提出的问题逐一投票，每人投三票,票数最多的三个问题将在下一跌代解决。之所以定义为三个问题，因为根据业内经验超过三个问题在一个迭代里很难有效解决。 </li><li>改进措施：强调共同分析，这一过程会将问题提到客观全面的高度，让团队能够更清晰的认识到问题的实质，进行问题分析。问题分析可用到的方法及工具应有很多种，比如头脑风暴、鱼骨图等。对于新的敏捷团队，敏捷教练也要发挥价值，引入一些好的建议及方法。最后挑选出在下轮迭代中切实可行的改进建议并指定责任人。 </li><li>问题跟进：下一迭代回顾会议总结开始前，大家一起根据《回顾会议问题一览表》回顾上一迭代问题的解决情况直至问题关闭。具体了解：待改进的问题是否落实并得到了 解决?解决办法是否可行？解决办法是否延用？如果没有得到解决就需要 在本次会议上重新进行讨论分析。也可能在解决别的问题同时已解决掉这个问题。</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>Q：是否需要邀请领导参加？</strong><br>A：因为回顾会议需要团队成员打开话题，畅所欲言。有些团队领导参加可能会影响到团队成员说真话。所以需根据团队自身情况决定，如1,2两个迭代过后，团队协作较为顺畅，可邀请领导支持者等参加。</p><p><strong>Q：是否可以以远程的形式开展会议？</strong><br>A：远程会议形式不仅耗费沟通成本，效果也会较差，SCRUM的一大特点就是Face To face，所以除特殊情况，还是要找个会议室开。</p><p><strong>Q：是否强制要求每个人都要发言？</strong><br>A：要求每个人都发言，做完一个迭代肯定会有感受的，参与才能融入其中。</p><p><strong>Q：回顾会议的结果是否需要正式记录？</strong><br>A：需要。回顾会议上最终确定要改进的问题及责任人要整理到书面文档里，发送团队全员。并且在下一迭代回顾会议上进行问题跟进，记录改进措施是否可行，问题是否解决。切实改进问题才能达到回顾会议的效果。</p><h2 id="Scrum管理实施步骤指南（2）-Sprint-计划会议"><a href="#Scrum管理实施步骤指南（2）-Sprint-计划会议" class="headerlink" title="Scrum管理实施步骤指南（2）  Sprint 计划会议"></a>Scrum管理实施步骤指南（2）  Sprint 计划会议</h2><h3 id="会议准备-1"><a href="#会议准备-1" class="headerlink" title="会议准备"></a>会议准备</h3><ul><li>邀请与会者：产品负责人、Scrum Master、团队所有成员</li><li>在sprint计划会议之前，要确保产品backlog的井然有序（已按优先级排列的产品 Backlog ）</li><li>把产品 Backlog 公开给会议中的每个人，保证其可被获取</li><li>保证房间环境适合小组讨论，一个比较安静的会议室，有投影仪</li><li>每个人都可以获取上次 Sprint 评审会议和 Sprint 回顾会议的结果 </li><li>用作计划纸牌的卡片</li><li>一个任务看板</li></ul><h3 id="会议进程"><a href="#会议进程" class="headerlink" title="会议进程"></a>会议进程</h3><p><strong>第一部分：产品负责人和团队一起，在先前评估的成果基础上，定出 Sprint 目标和Sprint  Backlog，决定在Sprint中需要完成哪些工作。</strong></p><ul><li>SM把 Sprint 完成周期公开给所有人</li><li>SM把 上一次Sprint 评审会议的结果公开给所有人</li><li>SM把 上一次Sprint 回顾会议的结果公开给所有人</li><li>PO向团队产品阐述产品远景，以及达成该远景所需要完成的产品Backlog，让团队成员了解客户的需求。</li><li>整个Scrum团队为了更好地了解Sprint的工作进行讨论。</li><li>PO和团队一起确认sprint目标。</li><li>团队初步确认要放入sprint中的Backlog。(sprint backlog)</li></ul><p><strong>第二部分：决定这些工作如何完成，并评估相应的完成时间。</strong></p><ul><li>团队从最重要的故事开始逐一讨论每个故事，估算时间。在必要的情况下拆分backlog条目，建议每个条目最好不要超过一天。拆分工作任务，SM带团队拆分 (task)</li><li>产品负责人在必要时修改重要性评分，理清每个条目的含义。(拆分sprint backlog 时做的)</li><li>产品负责人和团队需要对“完成”有一致的定义。</li><li>确定评审会日期</li><li>确定回顾会日期</li><li>确定每日站会时间和地点</li><li>制作任务看板和燃尽图</li><li>Sprint计划会议结束时，开发团队最好能够解释他们将如何以自组织团队的形式完成Sprint目标并开发期望的产品</li></ul><h3 id="会议输出"><a href="#会议输出" class="headerlink" title="会议输出"></a>会议输出</h3><ul><li>Sprint 目标和 Sprint Backlog</li><li>任务看板（含燃尽图）</li><li>确定好sprint演示日期</li><li>确定好sprint回顾日期</li><li>确定好时间地点，供举行每日站会</li></ul><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>参会人员哪些是必须的？</strong><br>PO是必须的，产品需求，客户价值就靠他了；SM必须的，他要保证流程，整个环节里面，他是最了解流程的，会议需要他把握节奏，风险等；团队成员更是必须的。三种角色缺一不可。</p><p><strong>sprint应该多长才好？</strong><br>经验证明一般2-4周比较合适，可以拥有足够的敏捷性，又让团队进入“流”的状态，团队刚开始要确定sprint的长度，不要浪费太多时间做分析，选一个可以接受的长度先开始再说，等做完一两个sprint再进行调整。</p><p>不过，团队确定了最合适长度之后，就要在长时间内坚持住。因为接下来的迭代过程有的时候会稍稍感觉有点长，有的时候感觉有点短。但保持住这个长度以后，它似乎变成了大家共同的心跳节奏，每个人都感觉很舒服。接下来无须讨论发布日期之类的事情，因为大家都知道：每过三周都会有一个发布。</p><p><strong>挑选任务的量是多少合适？</strong><br>建议是（Sprint周期）<em>0.8~（Sprint周期）</em> 1.2，防止乐观估计和悲观估计，保证悲观的时候可以完成，乐观的时候有的做。把0.8~1.2之间的内容放到缓冲区中，以备挑选。</p><p><strong>Sprint过程中，Sprint backlog是否可以随意添加？</strong><br>由SM进行风险把控，确保整个Sprint不被影响。需要判断添加的backlog优先级，是否紧急，sprint剩余工作量等进行综合考虑。</p><p><strong>在sprint计划会议之前，要确保产品backlog的井然有序，是什么意思？</strong><br>井然有序表示的意思是： 所有重要的backlog条目都已经根据重要性被评过分，不同的重要程度对应不同的分数。</p><p>无论任何故事，如果产品负责人认为它会在下一个sprint实现，那它就应该被划分到一个特有的重要性层次。</p><p>分数只是用来根据重要性对backlog条目排序。假如A的分数是20，而B的分数是100，那仅仅是说明B比A重要而已，绝不意味着B比A重要五倍。如果B的分数是21而不是100，含义也是一样的。</p><p>最好在分数之间留出适当间隔，以防后面出现一个C，比A重要而不如B重要。当然我们也可以给C打一个20.5分，但这样看上去就很难看了，所以我们还是留出间隔来。</p><p><strong>是否可以把一个产品backlog当做一个Sprint backlog？</strong><br>看情况而定，如果产品backlog就是一个比较小的特性来说，是可以的，如果产品backlog确实很大，那么作为Sprint backlog来说，就不太合适了。建议每个Sprint backlog最好不要超过一天。</p><h2 id="Scrum管理实施步骤指南（1）-Sprint日站立会议"><a href="#Scrum管理实施步骤指南（1）-Sprint日站立会议" class="headerlink" title="Scrum管理实施步骤指南（1）  Sprint日站立会议"></a>Scrum管理实施步骤指南（1）  Sprint日站立会议</h2><h3 id="会议准备-2"><a href="#会议准备-2" class="headerlink" title="会议准备"></a>会议准备</h3><ul><li>确定会议主持人：SM或团队成员轮流。</li><li>确定参会人员：团队所有成员、Scrum Master、产品负责人（可选）、相关人员（可选）。</li><li>选择一个合适的固定地点，便于团队成员站立围成一圈进行交流，建议选择靠近团队办公的地点。</li><li>确定一个合适的固定时间，便于团队成员养成一个习惯，这样就不要每次开会都要下通知了，建议每日早上9:00。</li><li>每日站会时要有任务看板，在看板上粘贴本项目组的任务状态和任务工作量：未开始的任务，进行中的任务，完成的任务。也可以借助一些敏捷的工具，例如JIRA系统，可以电子化sprint backlog。物理看板更有视觉的冲击力，电子看板更便于查询、统计、度量和优化。团队成立初期可以采用物理看板，后续团队在持续迭代的过程中需要进行过程数据分析，以便不断改进优化，电子看板将必不可少</li></ul><h3 id="会议进程（15-分钟内）"><a href="#会议进程（15-分钟内）" class="headerlink" title="会议进程（15 分钟内）"></a>会议进程（15 分钟内）</h3><ul><li>主持人召集并控制会议时间，会议中注意引导话题，如果相关人员想发表些言论，礼貌地提醒他，该会议只允许让小组成员讨论。</li><li>会中团队成员每个人就3个问题回答，并且更新每个任务的进展状态，直接在白板上移动任务贴纸：<ul><li>昨天我为开发团队达成Sprint目标做了什么？（要关注细节，又不能过分详细）<ul><li>如果任务状态为已完成，把任务从“待处理”或“处理中”转为“已完成”状态；</li><li>如果任务状态为进行中，把任务从“待处理”转为“处理中”状态；</li><li>如果任务状态已经是“处理中”，需标明剩余工作量，并说明是否存在阻碍任务完成得问题；</li><li>如果任务不在 Sprint Backlog 上，添加这个任务，并标明工作量。</li></ul></li><li>今天我准备如何帮助团队达成Sprint目标？ （当成员间的工作有依赖关系时，会给其他成员一个很好的提醒）<ul><li>如果任务状态为“待处理”转为“处理中”状态</li><li>如果任务状态已经是“处理中”，，需标明剩余工作量，说明是否存在阻碍任务完成得问题</li><li>如果任务不在 Sprint Backlog 上，添加这个任务，并标明工作量</li></ul></li><li>遇到有什么事情阻碍了我帮助团队达成Sprint目标？（让团队成员认识到在任何任务中他们都不是孤立的） <ul><li>如果有阻碍团队开发进度的问题，把该障碍加入到障碍 Backlog 中。</li><li>如果有问题需要讨论，但只需要几句话的讨论，那么在会上解决；否则需要详细讨论的，记下来，单独安排一个会议专门讨论。</li></ul></li></ul></li><li>在会议结束时，主持人计算剩余的工作量，更新燃尽图，预测达成Sprint目标的可能性，可以做个简短的总结，我们在何处？我们离目标有多远？</li><li>会后SM要及时解决会议上提出的问题，否则会影响大家，反映问题的积极性。</li></ul><h3 id="会议输出-1"><a href="#会议输出-1" class="headerlink" title="会议输出"></a>会议输出</h3><ul><li>得到最新的障碍 Backlog</li><li>得到最新的 Sprint Backlog</li><li>最新的燃尽图</li></ul><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>每日站会有必要每天召开吗？</strong><br>项目的延期源自每天的延期，所以要每天实时跟踪进展，站立会议必须每天都要开。</p><p><strong>每日站会可以用邮件代替吗？</strong><br>站立会议重在面对面的沟通，不能用邮件替代，E-mail只会增加沟通成本，而且不能提供细节信息或者给他人问问题的机会。</p><p><strong>每日站会仅仅是状态汇报吗？</strong><br>每日站会不是状态汇报，避免团队成员陷入提供状态相关信息的这样一种模式。</p><p>真正价值在于优化开发团队达成Sprint目标的可能性，激励团队成员不断地为达成“承诺”而努力。</p><p><strong>每日站会项目组外部的管理人员能够参加吗，可以发言吗？</strong><br>站立会议只允许团队成员讲话，项目组外部的管理人员可以列席，尤其是主管领导，但不能发言，不能下指令，只能旁听。在SCRUM中提倡的是团队自我管理。 </p><p><strong>每日站会可以坐着开吗？</strong><br>不能围在桌子周围坐着开，所有人站立围成一圈，站立暗示这个会会很短，强迫大家更专注和投入，还可以避免有人坐着收发邮件和其他分心的事情。</p><p><strong>站立会是向SM汇报吗？</strong><br>不是，成员在回答三个问题时目光要注视着大家，而不是 Scrum Master，否则就变成了向领导汇报工作。对每个人回答的问题有疑问，其他成员都可以提出，而不是只有Scrum Master 一个人在问。大家是平等的，这也是一种文化的培养。  </p><p><strong>每日会议时间一般多长？</strong><br>应该控制在15分钟之内，如果要讨论技术问题，会后单独开会，少数人参与讨论。</p><p><strong>如果有人开会总是迟到怎么办？</strong><br>建议制定惩罚措施，例如每次罚款10元，定期用罚款买一些小零食给团队成员分享，培养团队守时的文化。</p><h2 id="Scrum管理实施步骤指南（1）-Sprint-评审会议"><a href="#Scrum管理实施步骤指南（1）-Sprint-评审会议" class="headerlink" title="Scrum管理实施步骤指南（1）  Sprint 评审会议"></a>Scrum管理实施步骤指南（1）  Sprint 评审会议</h2><h3 id="会议准备-3"><a href="#会议准备-3" class="headerlink" title="会议准备"></a>会议准备</h3><ul><li>评审会议之前，由测试人员准备本迭代成果的演示环境，PO/需求人员协作测试团队准备演示数据，脚本等。<ul><li>演示环境建议使用独立的环境，非开发环境。</li><li>评审会议之前，PO/需求/测试保证所有迭代已验证条目部署到演示环境。</li><li>基于用户业务场景设计演示的操作线路，并保证覆盖到该场景下所有的待演示条目。</li></ul></li><li>PO确定并邀请参会人员，通常有：Scrum团队（PO、SM、开发测试、UE/UI、敏捷教练）、用户/用户代表、其他相关干系人（如：产品线相关人员、管理人员等）。</li><li>会议资料通常有：Sprint目标、Sprint backlog等</li></ul><h3 id="完成情况说明及产品演示"><a href="#完成情况说明及产品演示" class="headerlink" title="完成情况说明及产品演示"></a>完成情况说明及产品演示</h3><ul><li>首先由SM描述本迭代目标,确保参会人员都了解目标。</li><li>SM说明本迭代开发任务完成情况，及未完成的原因说明，需求/UE协助补充验证情况，测试依据测试报告补充测试情况。</li><li>通常由测试人员依据《Sprint backlog》进行产品演示；</li><li>参会人员根据上述演示及说明提出疑问，Scrum团队进行回答，并记  录发现的问题及期望的改进，改进可能是新的功能需求或一个功能的调整完善。</li><li>用户/PO最后依据产品演示、需求/UI/测试的验证情况，接受或拒绝 Sprint开发成果。</li><li>根据1）中的记录及2）的结果调整PBI。会后根据评审通过情况进行基线标识。</li></ul><h3 id="会议输出-2"><a href="#会议输出-2" class="headerlink" title="会议输出"></a>会议输出</h3><ul><li>《Product Backlog清单及验证》/《Sprint Backlog清单及验证》</li><li>《Sprint验证问题一览表》《标识Sprint基线清单》</li></ul><h3 id="评审会规则"><a href="#评审会规则" class="headerlink" title="评审会规则"></a>评审会规则</h3><ul><li>迭代评审会在迭代结束前的最后一天进行，不能延期；</li><li>评审会议时间，建议根据迭代周期时间，一周对应一小时。</li><li>演示过程中，建议不要展开讨论，先记录下来演示结束后讨论。</li><li>评审通过标准：用户/PO结合演示情况及测试报告决定是否可交付</li></ul><h1 id="Scrum-三大工件"><a href="#Scrum-三大工件" class="headerlink" title="Scrum 三大工件"></a>Scrum 三大工件</h1><h2 id="Scrum工件"><a href="#Scrum工件" class="headerlink" title="Scrum工件"></a>Scrum工件</h2><ul><li>定义： 以不同的方式表现工作任务和价值，可以用来提供透明性以及检查和调整的机会；</li><li>特性：<ul><li>透明度： Scrum依赖于透明性，所作出的优化价值和控制风险的决定都是基于所获知的工件状态。工件的状态必须是完全透明的，才能为产品作出决定提供一个坚实的基础；否则，作出的决定就是有缺陷的。</li><li>“完成” 定义：统一完成标准，团队理解一致；</li></ul></li></ul><h2 id="产品待办列表"><a href="#产品待办列表" class="headerlink" title="产品待办列表"></a>产品待办列表</h2><ul><li>一个有序的列表，其中包含产品需要的一切可能的东西，也是产品需求变动的唯一来源</li><li>产品待办列表项包含描述、次序、估算和价值；</li><li>“产品待办列表细化”指的是为列表项补充细节、估算和排序</li></ul><p><strong>监控实现目标的进度</strong>   </p><ul><li>产品负责人至少要在每个Sprint评审会议的时候追踪剩余工作总量。</li><li>产品负责人比较这个数量与之前Sprint评审时的剩余工作量，来评估在希望的时间点达成目标的进度。</li></ul><p><strong>监控预测进度工具：</strong></p><ul><li>趋势燃尽图（burn-downs）</li><li>燃烧图（burn-ups）</li><li>累积型的工作流（cumulative flows）</li></ul><h2 id="Sprint待办列表"><a href="#Sprint待办列表" class="headerlink" title="Sprint待办列表"></a>Sprint待办列表</h2><ul><li>一组为当前Sprint选出的产品待办列表项，外加交付产品增量和实现Sprint目标的计划</li><li>Sprint待办列表拥有足够的细节，因此能够在每日站会中对进度的变化有清楚的认识</li><li>随着任务的进行或者完成，团队需要估算并更新剩余的工作量</li></ul><p><strong>监控Sprint进度</strong></p><ul><li>在Sprint中的任意时间点都可以计算Sprint待办列表中所有剩余工作的总和。</li><li>开发团队在每日站会时跟踪剩余的工作量，预测达成Sprint目标的可能性。</li><li>团队通过在Sprint中不断跟踪剩余的工作量来管理自己的进度。</li></ul><h2 id="增量"><a href="#增量" class="headerlink" title="增量"></a>增量</h2><ul><li>一个Sprint完成的所有产品待办列表项，以及之前所有Sprint所产生的增量价值的总和；</li><li>在Sprint的结尾，新的增量必须是“完成”的，必须可用并且达到了Scrum团队“完成”的定义的标准；</li><li>无论产品负责人是否决定真正发布它，增量必须可用；</li></ul><p><strong>Scrum Master的职责之一</strong>：和Scrum团队以及企业一起增加工件的透明性<br><strong>Scrum Master的职责之二</strong>：和Scrum团队一起明确团队的完成标准</p><h1 id="燃尽图"><a href="#燃尽图" class="headerlink" title="燃尽图"></a>燃尽图</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是在项目完成之前，对需要完成的工作的一种可视化表示。燃尽图有一个Y轴（工作）和X轴（时间）。理想情况下，该图表是一个向下的曲线，随着剩余工作的完成，“烧尽”至零。燃尽图向项目组成员和管理层提供工作进展的一个公共视图。</p><p>燃尽图描述的是项目团队随着时间的推移而剩余的工作量，它能形象地展示当前迭代中的剩余工作量和剩余工作时间的变化趋势，是反应项目进展的一个指示器。这种可视化的管理方式，能够帮助团队工作进展更加透明。</p><p>您可以使用物理的白板＋手工更新来维护燃尽图，也可以使用EXCEL来生成和更新燃尽图也可以使用一些的敏捷团队协作工具（如：Leangoo等）来自动生成和更新燃尽图。</p><p>维护燃尽图是项目团队的日常工作。一般在每日例会后（对于敏捷研发项目，是指每日站立会）后，团队会根据任务的完成情况对其进行更新。这种可视化、简单易操作的管理方式能够帮助团队提升协作效率，并使团队工作进展更加透明，而过重的管理工具会成为团队的负担。</p><p>项目团队可以从燃尽图中识别出当前迭代的风险和问题，以便及时采取对策解决问题、规避风险。</p><p>另外，可以通过对多个迭代的燃尽图的持续分析，来对项目团团队进行持续地改进</p><h2 id="实施方法"><a href="#实施方法" class="headerlink" title="实施方法"></a>实施方法</h2><p><strong>燃尽图组成：燃尽图通常由4个核心部分组成</strong></p><ul><li>燃尽图横坐标：表示工期；</li><li>燃尽图纵坐标：表示要完成的工作；</li><li>计划曲线：假定项目组成员工作生产率恒定下的进度曲线；</li><li>实际曲线：实际进度曲线。<br><img src="/images/敏捷/燃尽图.png" alt=""></li></ul><p><strong>燃尽图绘制</strong></p><ol><li>绘制时间点：<br>在项目组进行完项目计划会议后进行燃尽图的绘制。对于敏捷研发项目来说，是在每个sprint计划会议后进行该sprint的燃尽图绘制</li><li>绘制方法：<br><strong>绘制人员</strong>：燃尽图绘制和后续的更新，由项目经理指定人员进行。可以是项目经理、SM、QA或团队里的其他成员</li></ol><p><strong>绘制方法</strong>：在业界用的比较多的绘制方法有二种（针对故事点燃尽、针对工作量燃尽），如下:</p><ul><li>步骤1：画出横轴和纵轴。横轴为工期，纵轴为故事点数【或工作量（人天）】。</li><li>步骤2：先出第一个点。第一个点，横坐标为开发周期的第一天，纵坐标为这个工期内估计能完成的总故事点数【或总工作量】。这个工期内估计能完成的总故事点数【总工作量】为计划会上估算的最终结果。</li><li>步骤3：找出项目计划结束点。计划结束点，横坐标为开发周期的最后一天，纵坐标为0。也就是计划在项目的最后一天“烧尽”至零。</li><li>步骤4：连接第一个点和项目计划结束点，产生的这个线就是“计划曲线”  </li></ul><ol start="3"><li>燃尽图“实际曲线”的更新<br>在每日例会后（对应敏捷研发项目，是指每日站立会），项目负责人安排人员计算出剩余工作的估算之和（剩余的故事点数，或剩余的总工作量），然后在燃尽图上画出一个新的点。直至项目结束，停止更新。<br><img src="/images/敏捷/燃尽图2.png" alt=""><br><img src="/images/敏捷/燃尽图3.png" alt=""></li></ol><h2 id="读懂燃尽图"><a href="#读懂燃尽图" class="headerlink" title="读懂燃尽图"></a>读懂燃尽图</h2><p>对于项目团队来讲，<a href="https://en.wikipedia.org/wiki/Burn_down_chart" target="_blank" rel="noopener">燃尽图</a>可以说的上是最有用的一种信息发射源（Information Radiator）。对燃尽图的分析，有助于把握团队的进展情况，另外可以还揭示很多问题，比如团队的表现如何、如何进一步改进等等。</p><p>燃尽图有助于回答的问题，例如： </p><ul><li>团队的计划制订情况如何？</li><li>在一个Sprint中，团队对计划的故事的执行情况如何？</li><li>团队是自我管理的么？作为“团队”来说，大家的工作步调一致么？</li><li>团队能进行哪些改进？</li></ul><p>可以借鉴和学习一些敏捷大师对燃尽图的分析和总结，来解读各项目自己的燃尽图，Hiren向我们展示了如右图这张图表：<br><img src="/images/敏捷/燃尽图4.png" alt=""></p><ul><li><strong>图表中的蓝线</strong> Hiren给出了自己的看法：该团队的计划并不好，因为线根本就没有触到零点，这其中的原因可能有很多。团队的一致性上也出现了问题，他们需要教练。因此，对于该团队来说，计划与自我管理方面亟需改进</li><li><strong>图中的紫线</strong>表明该团队已经达成了目标，但并没有主动去更新数字，原因可能有二：要么他们太懒了，没有更新剩余的工作量；要么是在该Sprint的最后舍弃了很多用户故事。</li><li><strong>图中的绿线</strong>表明对于一个计划良好的成熟团队工作量的燃尽情况，该团队是自我管理并且在整个Sprint中拥有足够的故事要去实现。这条线接近于理想情况，表明了软件开发的复杂性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scrum团队-三大角色&quot;&gt;&lt;a href=&quot;#Scrum团队-三大角色&quot; class=&quot;headerlink&quot; title=&quot;Scrum团队-三大角色&quot;&gt;&lt;/a&gt;Scrum团队-三大角色&lt;/h1&gt;&lt;p&gt;Scrum团队：由产品负责人、开发团队和Scrum Mast
      
    
    </summary>
    
      <category term="研发管理" scheme="http://wushuning.com/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="笔记" scheme="http://wushuning.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="研发管理" scheme="http://wushuning.com/tags/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PM、RD、QA、OP等英文缩写是什么意思？</title>
    <link href="http://wushuning.com/2018/10/26/%E7%A0%94%E5%8F%91%E4%B8%AD%E5%90%84%E7%A7%8Dtitle-RD-PM%E7%AD%89%E5%90%AB%E4%B9%89/"/>
    <id>http://wushuning.com/2018/10/26/研发中各种title-RD-PM等含义/</id>
    <published>2018-10-25T16:00:00.000Z</published>
    <updated>2018-10-26T09:12:43.162Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PM</strong>: Product Manager，产品经理，又称品牌经理。举凡产品从创意到上市，所有相关的研发、调研、生产、编预算、广告、促销活动等等，都由产品经理掌控。<br><strong>RD</strong>: Research and Development engineer，研发工程师，对某种不存在的事物进行系统的研究和开发并具有一定经验的专业工作者,或者对已经存在的事物进行改进以达到优化目的的专业工作者。<br><strong>QA</strong>: Quality Assurance，品质保证。QA的主要职责就是质量保证工作。<br><strong>OP</strong>: Operator，操作员，管理员。<br><strong>PO</strong>: Product Owner 项目负责人</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;PM&lt;/strong&gt;: Product Manager，产品经理，又称品牌经理。举凡产品从创意到上市，所有相关的研发、调研、生产、编预算、广告、促销活动等等，都由产品经理掌控。&lt;br&gt;&lt;strong&gt;RD&lt;/strong&gt;: Research and De
      
    
    </summary>
    
      <category term="研发管理" scheme="http://wushuning.com/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="笔记" scheme="http://wushuning.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="研发管理" scheme="http://wushuning.com/tags/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>QCon2018全球软件开发大会PPT合集</title>
    <link href="http://wushuning.com/2018/10/24/QCon2018%E5%85%A8%E7%90%83%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BC%9APPT%E5%90%88%E9%9B%86/"/>
    <id>http://wushuning.com/2018/10/24/QCon2018全球软件开发大会PPT合集/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-29T06:10:02.429Z</updated>
    
    <content type="html"><![CDATA[<p>QCon2018全球软件开发大会PPT合集<br>链接: <a href="https://pan.baidu.com/s/1CSD8SJg5eMqpoC3TEH3XmQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1CSD8SJg5eMqpoC3TEH3XmQ</a>  密码:lthe</p><p>QCon大会是由InfoQ中文站主办的全球顶级技术盛会，每年在伦敦，北京，东京，纽约，圣保罗，上海，旧金山召开。自2007年3月份首次举办以来，已经有超万名高级技术人员参加过的QCon大会。 QCon内容源于实践并面向社区，演讲嘉宾依据热点话题，面向5年以上工作经验的技术团队负责人，架构师，工程总监，高级开发人员分享技术创新和最佳实践。</p><h1 id="2018-QCon全球软件开发大会演讲专题"><a href="#2018-QCon全球软件开发大会演讲专题" class="headerlink" title="2018 QCon全球软件开发大会演讲专题"></a>2018 QCon全球软件开发大会演讲专题</h1><h2 id="产品经理必修之用户细分与产品定位"><a href="#产品经理必修之用户细分与产品定位" class="headerlink" title="产品经理必修之用户细分与产品定位"></a>产品经理必修之用户细分与产品定位</h2><p>产品经理遇到的最大的问题是自认为炫酷的产品没有用户去使用，因此产品经理的第一节必修课就是在确定产品的价值主张之后，对产品的最终用户进行详细的细分与定义，确定产品的定位。</p><h2 id="工程师个人成长与技术领导力"><a href="#工程师个人成长与技术领导力" class="headerlink" title="工程师个人成长与技术领导力"></a>工程师个人成长与技术领导力</h2><p>工程师成长就是从关心自己的事到关心别人的事，再到关心公司的事的历程。本专题将为大家分享个人成长和技术管理的技巧，帮助大家实现从“做人做事”到“带人带事”的职场跃迁。</p><h2 id="国际化互联网业务架构"><a href="#国际化互联网业务架构" class="headerlink" title="国际化互联网业务架构"></a>国际化互联网业务架构</h2><p>随着全球互联网的蓬勃发展，越来越多的公司把业务拓展到国外，这一变化给技术带来很多新的挑战。本专题旨在发掘在国际化架构先行者的经验，碰撞并探索一套可供参考的国际化架构模式。</p><h2 id="互联网高可用架构"><a href="#互联网高可用架构" class="headerlink" title="互联网高可用架构"></a>互联网高可用架构</h2><p>本专题将为您解答大规模互联网系统的架构设计和实现案例，如何做到高可用和可扩展？大规模互联网系统的设计，开发和运维，有哪些值得借鉴的经验和理念？业界有哪些最新的探索实践和踩坑经历？</p><h2 id="后移动互联网时代的技术思考与实践"><a href="#后移动互联网时代的技术思考与实践" class="headerlink" title="后移动互联网时代的技术思考与实践"></a>后移动互联网时代的技术思考与实践</h2><p>移动互联网进入下半场，相关基础设施建设趋于成熟，跨平台技术仍在不断发展和创新，音视频，移动端AI落地实践，智能硬件，移动端安全等都是不容忽视的话题。希望本专题能给大家带来新的启迪。</p><h2 id="大规模基础设施的DevOps探索"><a href="#大规模基础设施的DevOps探索" class="headerlink" title="大规模基础设施的DevOps探索"></a>大规模基础设施的DevOps探索</h2><p>业务的爆发式增长，让运维大规模基础设施成为了新的痛点。本专题中，来自一线的运维研发同学，为大家分享针对多数据中心，海量服务器和网络配置，跨应用场景，如何搭建高效准确的运维管理监控平台</p><h2 id="硅谷人工智能"><a href="#硅谷人工智能" class="headerlink" title="硅谷人工智能"></a>硅谷人工智能</h2><p>以谷歌，Facebook等公司为代表，硅谷在人工智能等领域一直走在世界前列。本专题将邀请硅谷有代表性互联网公司的技术专家，分享人工智能领域的前沿研发经验。</p><h2 id="硅谷运维技术"><a href="#硅谷运维技术" class="headerlink" title="硅谷运维技术"></a>硅谷运维技术</h2><p>硅谷的互联网公司在运维方面有很多独到之处。像Chaos Engineering和Resilience Engineering在国内外都有很高的关注度。本专题将邀请来自硅谷的专家，分享运维方面的最新工具与实践。</p><h2 id="人工智能与业务实践"><a href="#人工智能与业务实践" class="headerlink" title="人工智能与业务实践"></a>人工智能与业务实践</h2><p>人工智能无疑是近年关注度最高的技术领域之一，很多公司在AI上投入大量资源，推动新技术在不同场景的落地，比如智能助手，自动驾驶等。本主题将从人工智能和业务结合的角度，分享人工智能领域的最新进展。</p><h2 id="Java的生态与创新"><a href="#Java的生态与创新" class="headerlink" title="Java的生态与创新"></a>Java的生态与创新</h2><p>Java的具有生机勃勃的生态圈，一直得到开发人员的青睐，占据开发语言排行首位的.java有坚实的平台，完整的应用开发栈，繁如群星的开源项目，强大软件和互联网公司后盾，同时也在不断创新和进化。</p><h2 id="大数据系统架构"><a href="#大数据系统架构" class="headerlink" title="大数据系统架构"></a>大数据系统架构</h2><p>业务的增长会带来大量数据，很多公司都搭建了自己的大数据处理平台，或者向新的数据平台/框架迁移。本专题将关注大数据平台技术选型，搭建，系统迁移和优化方面的经验。</p><h2 id="区块链技术与应用"><a href="#区块链技术与应用" class="headerlink" title="区块链技术与应用"></a>区块链技术与应用</h2><p>随着各种数字货币的火爆，区块链技术也成为大家关注的焦点。本专题将邀请相关专家，分享区块链在典型业务场景下的落地思考，阐述背后的设计思想和技术架构。</p><h2 id="前端新趋势"><a href="#前端新趋势" class="headerlink" title="前端新趋势"></a>前端新趋势</h2><p>前端技术日新月异，在技术的演进过程中，也有很多设计思想和架构经验值得前端工程师学习本专题将关注3个方面：实践中积累的前端架构经验，典型的前端框架应用经验，新型框架与设计思路。</p><h2 id="深度学习技术与应用"><a href="#深度学习技术与应用" class="headerlink" title="深度学习技术与应用"></a>深度学习技术与应用</h2><p>本专题将关注深度学习技术在具体业务领域的应用与发展。</p><h2 id="微服务架构＆无服务器"><a href="#微服务架构＆无服务器" class="headerlink" title="微服务架构＆无服务器"></a>微服务架构＆无服务器</h2><p>微服务架构近年来受到持续关注，很多公司也在对原有系统做微服务架构改造。本专题将涉及微服务架构模式，改造经验及相关配套技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;QCon2018全球软件开发大会PPT合集&lt;br&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1CSD8SJg5eMqpoC3TEH3XmQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.c
      
    
    </summary>
    
      <category term="开发者大会" scheme="http://wushuning.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A/"/>
    
    
      <category term="笔记" scheme="http://wushuning.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo结合gitpage搭建无限空间静态博客</title>
    <link href="http://wushuning.com/2018/10/19/hexo%E7%BB%93%E5%90%88gitpage%E6%90%AD%E5%BB%BA%E6%97%A0%E9%99%90%E7%A9%BA%E9%97%B4%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://wushuning.com/2018/10/19/hexo结合gitpage搭建无限空间静态博客/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-19T08:07:03.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://wushuning.com/2018/10/01/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>生成静态网页即可托管到任何支持静态网页的服务器上。</p><h1 id="什么是GitPage"><a href="#什么是GitPage" class="headerlink" title="什么是GitPage"></a>什么是GitPage</h1><p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> 与GitHub同属一个研发组织，免费为你的GitHub项目提供项目部署和托管服务，一个GitHub账号可以创建一个GitPage空间。GitPage支持静态和markdown语法的项目，并与GitHub上的项目实时同步自动渲染。所以你可以很容易使用GitPage搭建自己的博客。</p><p>特别注意：一个GitHub账号只能创建一个GitPage空间，并且名称有特殊要求下文详细说明。</p><p>可选框架：<br><a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">jekyll</a></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodejs</span><br><span class="line">Git</span><br></pre></td></tr></table></figure><h1 id="创建github账号和同名项目"><a href="#创建github账号和同名项目" class="headerlink" title="创建github账号和同名项目"></a>创建github账号和同名项目</h1><ul><li>申请账号如:wangzhikui</li><li>创建同名项目:wangzhikui.github.io  </li></ul><p>如图:<br><img src="/images/hexo/hexo-gitpage-1.png" alt=""></p><p>进入项目的【setting &gt; GitHub Pages】</p><p>如图：</p><p><img src="/images/hexo/hexo-gitpage-2.png" alt=""><br>按照描述设置开启即可。</p><p>到此为止GitPages已经可以使用，提交到wangzhikui.github.io的静态或markdown形式的文件会自动同步到GitPages空间。可通过<a href="http://wangzhikui.github.io访问。" target="_blank" rel="noopener">http://wangzhikui.github.io访问。</a></p><h1 id="配置域名-无此需要可跳过"><a href="#配置域名-无此需要可跳过" class="headerlink" title="配置域名(无此需要可跳过)"></a>配置域名(无此需要可跳过)</h1><h2 id="一、上一步GitPages设置中设置域名如：wushuning-com"><a href="#一、上一步GitPages设置中设置域名如：wushuning-com" class="headerlink" title="一、上一步GitPages设置中设置域名如：wushuning.com"></a>一、上一步GitPages设置中设置域名如：wushuning.com</h2><h2 id="二、配置域名的A地址和CNAME别名"><a href="#二、配置域名的A地址和CNAME别名" class="headerlink" title="二、配置域名的A地址和CNAME别名"></a>二、配置域名的A地址和CNAME别名</h2><p>本域名在阿里云申请，所以登录aliyun.com进入域名配置，域名解析做如下配置</p><p><img src="/images/hexo/域名配置.png" alt="域名配置"></p><h2 id="三、项目根目录中添加名为CNAME的文件，内容为-wushuning-com"><a href="#三、项目根目录中添加名为CNAME的文件，内容为-wushuning-com" class="headerlink" title="三、项目根目录中添加名为CNAME的文件，内容为 wushuning.com"></a>三、项目根目录中添加名为CNAME的文件，内容为 wushuning.com</h2><p><img src="/images/hexo/cname.png" alt="CNAME"></p><h1 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h1><h2 id="安装hexo并使用hexo创建项目"><a href="#安装hexo并使用hexo创建项目" class="headerlink" title="安装hexo并使用hexo创建项目"></a>安装hexo并使用hexo创建项目</h2><p>安装hexo脚手架工具并使用脚手架创建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init wangzhikuiblog</span><br><span class="line">cd wangzhikuiblog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><ol><li>全局安装脚手架hexo-cli</li><li>创建一个名为wangzhikuiblog的项目</li><li>进入项目目录</li><li>安装依赖包</li><li>启动服务</li></ol><p>服务启动成功出现如下图：<br><img src="/images/hexo/hexo-start.png" alt=""></p><p>通过<a href="http://localhost:4000访问示例程序" target="_blank" rel="noopener">http://localhost:4000访问示例程序</a><br>到此使用hexo创建项目已经完成</p><h2 id="手动部署"><a href="#手动部署" class="headerlink" title="手动部署"></a>手动部署</h2><p>进入项目目录运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><p>则会在项目路径中生成一个public文件夹，里边的内容即为hexo为我们生成的所有静态文件。手动将public里边的所有文件git传到wangzhikui.github.io即可。</p><p>到此可通过<br><a href="http://wangzhikui.bighub.io" target="_blank" rel="noopener">http://wangzhikui.bighub.io</a><br>或域名（如果配置了）<br><a href="http://wushuning.com">http://wushuning.com</a><br>访问你的网站。</p><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>打开项目根目录下的_config.yml 找到如下配置:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span></span><br><span class="line"><span class="attr">    github:</span> <span class="string">git@github.com:wangzhikui/wangzhikui.github.io.git</span></span><br></pre></td></tr></table></figure></p><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>则将public下的文件部署到wangzhikui.github.io.git上，我这里只有一个分支master，所以默认，如果要填写分支可以配置repo。建议保持一个分支就可以了。</p><p>hexo d 命令push代码使用的是ssh，所以需要配置github的ssh key 关于key生成配置这里不赘述。</p><p><strong><code>注：如果本地要维护两个github账号，这种情况有可能遇到ssh key冲突，该情况在下一篇博文描述</code></strong></p><h2 id="hexo生成的项目目录结构简介"><a href="#hexo生成的项目目录结构简介" class="headerlink" title="hexo生成的项目目录结构简介"></a>hexo生成的项目目录结构简介</h2><p>使用hexo创建的项目路径如下图：</p><p><img src="/images/hexo/hexo-project.png" alt="hexo 项目结构">  </p><p><a href="https://github.com/wangzhikui/wangzhikuiblog" target="_blank" rel="noopener">项目源码</a></p><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">简写</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">hexo server</td><td style="text-align:left">hexo s</td><td style="text-align:left">启动服务</td></tr><tr><td style="text-align:left">hexo generate</td><td style="text-align:left">hexo g</td><td style="text-align:left">生成静态文件</td></tr><tr><td style="text-align:left">hexo deploy</td><td style="text-align:left">hexo d</td><td style="text-align:left">将静态文件部署到github上</td></tr><tr><td style="text-align:left">hexo clean</td><td style="text-align:left">无</td><td style="text-align:left">清除缓存文件 (db.json) 和已生成的静态文件 (public)</td></tr></tbody></table><p>查看更多命令: <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo 命令大全</a></p><p>本人在部署的时候喜欢使用三个命令组合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>主题文件存放在 /themes下。本博客基于主题<a href="https://github.com/cofess/hexo-theme-pure" target="_blank" rel="noopener">hexo-theme-pure</a> 修改而来。大家也可前往<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo 主题库</a> 下载自己需要的主题。</p><p>下载主题后放入/thems下</p><p>打开项目根目录的配置文件._config.yml.修改配置theme为你主题的文件夹名称即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: hexo-theme-yyy</span><br></pre></td></tr></table></figure></p><h2 id="创建博文"><a href="#创建博文" class="headerlink" title="创建博文"></a>创建博文</h2><h3 id="通过命令"><a href="#通过命令" class="headerlink" title="通过命令"></a>通过命令</h3><p>进入项目目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new test</span><br></pre></td></tr></table></figure></p><p>常见一篇名为test.md的博文，路径在/source/_posts/test.md<br>打开test.md使用markdown编辑即可。</p><h3 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h3><p>直接在_posts文件夹下创建一个test.md的文件即可</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><blockquote><p>hexo的_config.yml和themes_config.yml分别有哪些重要配置</p></blockquote><blockquote><p>hexo中博文md文件都有哪些配置</p></blockquote><blockquote><p>hexo中使用gitalk添加评论功能</p></blockquote><blockquote><p>一个hexo主题都包含什么，如何入手修改主题满足自己个性化设置</p></blockquote><blockquote><p>本地同时维护两个github账号如何设置ssh key</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Hexo&quot;&gt;&lt;a href=&quot;#什么是Hexo&quot; class=&quot;headerlink&quot; title=&quot;什么是Hexo&quot;&gt;&lt;/a&gt;什么是Hexo&lt;/h1&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;http://wush
      
    
    </summary>
    
      <category term="博客" scheme="http://wushuning.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://wushuning.com/tags/hexo/"/>
    
      <category term="github" scheme="http://wushuning.com/tags/github/"/>
    
      <category term="gitpage" scheme="http://wushuning.com/tags/gitpage/"/>
    
  </entry>
  
  <entry>
    <title>web全栈技术图谱v1.0</title>
    <link href="http://wushuning.com/2018/10/18/web%E5%85%A8%E6%A0%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1v1-0/"/>
    <id>http://wushuning.com/2018/10/18/web全栈技术图谱v1-0/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-19T08:10:15.416Z</updated>
    
    <content type="html"><![CDATA[<p>根据自己接触到的技术体系整理了一个web全栈技术图谱v1.0。做个记录<br><img src="/images/web全栈技术图谱v1.0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据自己接触到的技术体系整理了一个web全栈技术图谱v1.0。做个记录&lt;br&gt;&lt;img src=&quot;/images/web全栈技术图谱v1.0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术图谱" scheme="http://wushuning.com/categories/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="技术图谱" scheme="http://wushuning.com/tags/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="前端" scheme="http://wushuning.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue基础教程(使用vue-cli搭建开发环境)</title>
    <link href="http://wushuning.com/2018/10/10/vue%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8vue-cli%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://wushuning.com/2018/10/10/vue基础教程-使用vue-cli搭建开发环境/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-10-23T13:59:11.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue环境搭建"><a href="#vue环境搭建" class="headerlink" title="vue环境搭建"></a>vue环境搭建</h2><p><a href="https://mp.weixin.qq.com/s/izYPuxjgxLuoay75cYKglw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/izYPuxjgxLuoay75cYKglw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue环境搭建&quot;&gt;&lt;a href=&quot;#vue环境搭建&quot; class=&quot;headerlink&quot; title=&quot;vue环境搭建&quot;&gt;&lt;/a&gt;vue环境搭建&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/izYPuxjgxLuoay
      
    
    </summary>
    
      <category term="vue" scheme="http://wushuning.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://wushuning.com/tags/vue/"/>
    
      <category term="vue-cli" scheme="http://wushuning.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>markdown常用语法</title>
    <link href="http://wushuning.com/2018/10/01/markdown/"/>
    <id>http://wushuning.com/2018/10/01/markdown/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-26T06:01:10.230Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考 <a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/#further-reading" target="_blank" rel="noopener">Github markdown 基本写法</a>，更多详细描述可直接前往Github查看 </p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#标题">标题</a></li><li><a href="#文本样式">文本样式</a></li><li><a href="#引用文本">引用文本</a></li><li><a href="#引用代码">引用代码</a></li><li><a href="#链接">链接</a></li><li><a href="#部分链接">部分链接</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- [标题](#标题)</span><br><span class="line">- [文本样式](#文本样式)</span><br><span class="line">- [引用文本](#引用文本)</span><br><span class="line">- [引用代码](#引用代码)</span><br><span class="line">- [链接](#链接)</span><br><span class="line">- [部分链接](#部分链接)</span><br></pre></td></tr></table></figure><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>文字前使用(1-6个)#，不同数量代表文字不一样大小</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 标题1</span><br><span class="line">## 标题2</span><br><span class="line">### 标题3</span><br><span class="line">#### 标题4</span><br><span class="line">##### 标题5</span><br><span class="line">###### 标题6</span><br></pre></td></tr></table></figure><h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><table><thead><tr><th style="text-align:left">样式</th><th style="text-align:center">语法</th><th style="text-align:right">快捷键</th><th style="text-align:right">示例</th><th style="text-align:right">效果</th></tr></thead><tbody><tr><td style="text-align:left">粗体</td><td style="text-align:center"><code>** **</code>或<code>__ __</code></td><td style="text-align:right">command/control + b</td><td style="text-align:right"><code>**Hello World**</code></td><td style="text-align:right"><strong>Hello World</strong></td></tr><tr><td style="text-align:left">斜体</td><td style="text-align:center"><code>* *</code>或<code>_ _</code></td><td style="text-align:right">command/control + i</td><td style="text-align:right"><code>*Hello World*</code></td><td style="text-align:right"><em>Hello World</em></td></tr><tr><td style="text-align:left">删除</td><td style="text-align:center"><code>~~ ~~</code></td><td style="text-align:right">无</td><td style="text-align:right"><code>~~Hello World~~</code></td><td style="text-align:right"><del>Hello World</del></td></tr><tr><td style="text-align:left">粗体&amp;斜体</td><td style="text-align:center"><code>~~ ~~</code>和<code>_ _</code></td><td style="text-align:right">无</td><td style="text-align:right"><code>**Hello _World_**</code></td><td style="text-align:right"><strong>Hello <em>World</em></strong></td></tr></tbody></table><p>表格源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 样式 | 语法 | 快捷键 | 示例 | 效果 |</span><br><span class="line">|:----|:----:|-----:|-----:|----:|</span><br><span class="line">| 粗体 | `** **`或`__ __` | command/control + b | `**Hello World**` | **Hello World**|</span><br><span class="line">| 斜体 | `* *`或`_ _` | command/control + i | `*Hello World*` | *Hello World* |</span><br><span class="line">| 删除 | `~~ ~~` | 无 | `~~Hello World~~` | ~~Hello World~~ |</span><br><span class="line">| 粗体&amp;斜体 | `~~ ~~`和`_ _` | 无 | `**Hello _World_**` | **Hello _World_** |</span><br></pre></td></tr></table></figure></p><h1 id="引用文本"><a href="#引用文本" class="headerlink" title="引用文本"></a>引用文本</h1><p>使用 &gt;，可以使用多个&gt;来嵌套</p><blockquote><p>被引用的文字</p><blockquote><p>被引用的文字2</p><blockquote><p>被引用的文字3  </p></blockquote></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 被引用的文字</span><br><span class="line">&gt;&gt; 被引用的文字2</span><br><span class="line">&gt;&gt;&gt; 被引用的文字3</span><br></pre></td></tr></table></figure><h1 id="引用代码"><a href="#引用代码" class="headerlink" title="引用代码"></a>引用代码</h1><p>使用如下标志将文字包含即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用``` ``` 将代码包含即可</span><br><span class="line">也可以加上语言来使得块中语法高亮</span><br><span class="line">  ``` java</span><br><span class="line">  ``` javascript</span><br><span class="line">  ``` html</span><br></pre></td></tr></table></figure><p>基础格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></p><p>java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  System.out.print(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>javascript<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello World <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Github使用<a href="https://github.com/github/linguist" target="_blank" rel="noopener">Linguist</a>进行语言检测，并选择<a href="https://github.com/github/linguist/blob/master/vendor/README.md" target="_blank" rel="noopener">第三方语法</a>进行语法突出显示。您可以在<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml" target="_blank" rel="noopener">YAML</a>文件中找到哪些关键字是有效的。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[友云音](http://yyy.yonyoucloud.com)</span><br></pre></td></tr></table></figure><p><a href="http://yyy.yonyoucloud.com" target="_blank" rel="noopener">友云音</a></p><p>链接可以使用相对地址</p><table><thead><tr><th style="text-align:left">语法</th><th style="text-align:center">目录</th></tr></thead><tbody><tr><td style="text-align:left">/</td><td style="text-align:center">根目录</td></tr><tr><td style="text-align:left">./</td><td style="text-align:center">当前目录</td></tr><tr><td style="text-align:left">../</td><td style="text-align:center">上级目录</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[友云音logo](/images/logo/youyunyin-logo.png)</span><br></pre></td></tr></table></figure><p><a href="/images/logo/youyunyin-logo.png">友云音logo</a></p><h1 id="部分链接"><a href="#部分链接" class="headerlink" title="部分链接"></a>部分链接</h1><p>当我们写好md发布渲染生成html之后，当鼠标移动到某一块的头部的时候会显示#（也有可能是其他图表），点击之后地址栏会生成一个部分连接。使用该地址栏的地址访问该文章会自动定位到点击的这个块。<br>比如本文的地址是:<br><a href="http://youyunyin.com/2018/10/01/markdown/" target="_blank" rel="noopener">http://youyunyin.com/2018/10/01/markdown/</a><br>点击[文本样式]这个标题，地址栏url变为<br><a href="http://youyunyin.com/2018/10/01/markdown/#文本样式" target="_blank" rel="noopener">http://youyunyin.com/2018/10/01/markdown/#文本样式</a><br>点击改链接就会直接进入该页面并跳转到[文本样式]块中</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>使用 - 或者 *</p><ul><li>第1行</li><li>第2行<ul><li>第2-1行<ul><li>第2-1-1行</li><li>第2-1-2行</li></ul></li><li>第2-2行</li></ul></li><li>第3行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 第1行</span><br><span class="line">- 第2行</span><br><span class="line">  - 第2-1行</span><br><span class="line">    - 第2-1-1行</span><br><span class="line">    - 第2-1-2行</span><br><span class="line">  - 第2-2行</span><br><span class="line">- 第3行</span><br></pre></td></tr></table></figure><p>使用数字  </p><ol><li>第1行</li><li>第2行</li><li>第3行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第1行</span><br><span class="line">2. 第2行</span><br><span class="line">3. 第3行</span><br></pre></td></tr></table></figure><h1 id="任务列表（gihub扩展，非标准markdown）"><a href="#任务列表（gihub扩展，非标准markdown）" class="headerlink" title="任务列表（gihub扩展，非标准markdown）"></a>任务列表（gihub扩展，非标准markdown）</h1><ul><li style="list-style: none"><input type="checkbox" checked> 任务1</li><li style="list-style: none"><input type="checkbox"> 任务2</li><li style="list-style: none"><input type="checkbox"> 任务3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 任务1</span><br><span class="line">- [ ] 任务2</span><br><span class="line">- [ ] 任务3</span><br></pre></td></tr></table></figure><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>文字后面输入两个空格换行</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><img src="/images/logo/youyunyin-logo.png" alt="友云音logo" title="友云音logo"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![友云音logo](/images/logo/youyunyin-logo.png &quot;友云音logo&quot;)</span><br></pre></td></tr></table></figure></p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>使用 三个以上 - 或 *<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure></p><hr><hr><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考 &lt;a href=&quot;https://help.github.com/articles/basic-writing-and-formatting-syntax/#further-reading&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Githu
      
    
    </summary>
    
      <category term="markdown" scheme="http://wushuning.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://wushuning.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>codereview常见问题</title>
    <link href="http://wushuning.com/2018/07/21/codereview%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://wushuning.com/2018/07/21/codereview常见问题/</id>
    <published>2018-07-20T16:00:00.000Z</published>
    <updated>2018-10-26T03:20:48.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h1><p><img src="/images/codereview-problem.png" alt=""></p><h1 id="常见代码问题"><a href="#常见代码问题" class="headerlink" title="常见代码问题"></a>常见代码问题</h1><p>常见的潜在代码问题是当前直接会导致BUG、故障或者产品功能不能正常工作的类别。</p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>空值是最容易的问题</p><ul><li>值为NULL导致空指针异常； </li><li>参数字符串含有前导或后缀空格没有Trim导致查询为空。 </li></ul><p>原则上，对于任何异常， 希望能够打印出具体的错误信息，根据错误信息很快明白是什么原因， 而不是一个 null ，还要在代码里去推敲为什么为空。这样我们必须识别出程序中可能的null， 并及时检测、捕获和抛出异常。</p><p>对于空值，最好的防护是“防御式编程”。当获取到对象之后， 使用之前总是判断是否为空，并适当抛出异常、打错误日志或做其它处理。 有的人嫌检测为空的 if 语句充斥在代码里会破坏代码的可维护性， 对此我的建议是：</p><p>空值检测一定要有， 有胜于无。<br>在空值检测总是存在的前提下， 可以优化空值检测的方法和存在形式。 比如集中于一个类 NullChecker 中管理，并与系统的整体错误处理设计保持一致。集中管理和处理一致性原则可以作为系统设计的一个准则。 这样主流程中只要增加一行调用即可， 既可以天网恢恢疏而不漏地检测对象为空， 也不会让代码显得难看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullChecker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNull</span><span class="params">(Object obj, Error error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)  &#123; <span class="keyword">throw</span> <span class="keyword">new</span> BizException(error); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在参数入口处统一做 trim。 如果在业务逻辑里做 trim ， 就会导致有的业务逻辑做了 trim ， 有的没做， 体现在产品上就会有令用户困惑的事情发生。 比如搜索和导出业务， 搜索能搜索出来， 导出却没有。</p><h2 id="未捕获潜在的异常"><a href="#未捕获潜在的异常" class="headerlink" title="未捕获潜在的异常"></a>未捕获潜在的异常</h2><p>第二个容易出错的地方是未捕获潜在的异常。调用API接口、库函数或系统服务等，只顾着享受便利却不做防护，常导致因为局部失败而影响整体的功能。最好的防护依然是“防御式编程”。 要么在当前方法捕获异常并返回合适的空值或空对象，要么抛给高层处理。</p><p>切不可默默”吞掉错误和异常”。 如果这样做了， 出问题了等着加班和耗费大量脑细胞吧！<br>在CodeReview的时候一定要仔细询问：这里是否可能会抛出异常？如果抛异常会怎么处理？是否会影响整体服务和返回结果？</p><h2 id="低性能"><a href="#低性能" class="headerlink" title="低性能"></a>低性能</h2><p>低性能会导致产品功能不好用、不可用，甚至导致产品失败。</p><p>常见情况有：</p><ol><li>循环地逐个调用单个接口获取数据或访问数据库; </li><li>重复创建几乎完全相同的(开销大的)对象；</li><li>数据库访问、网络调用等服务未处理超时的情况； </li><li>多重循环对于大数据量处理的算法性能低；</li><li>大量字符串拼接时使用了String而非StringBuilder.</li></ol><p>处理建议</p><ol><li>最好提供批量接口或批量并发获取数据； </li><li>将可复用对象抽离出循环，一次创建多次使用；</li><li>设置合理的超时时间并捕获超时异常处理； </li><li>使用预排序或预处理， 构造合适的数据结构， 使得算法平均性能在 O(n) 或 O(nlogn) ； </li><li>少量字符串拼接使用String, 大量字符串拼接使用 StringBuilder， 通常不会使用到 StringBuffer.</li></ol><h2 id="影响范围过大"><a href="#影响范围过大" class="headerlink" title="影响范围过大"></a>影响范围过大</h2><p>对多个模块依赖的公共函数的修改，容易造成影响范围超过当前业务改动，无意识地破坏依赖于该公共函数的其他业务。要特别慎重。可靠的方式是：先查看该公共函数的调用， 如果只有自己的业务用，可适当大胆一些； 如果有多个地方依赖，抽离一个新的函数，抽离原函数里的可复用部分，然后基于可复用部分构建新的函数。修改原则遵循“开闭”原则，才能尽可能使改动影响降低到最小化。</p><p>基类及实例字段和方法也属于公共函数的范畴。 尽量不要修改基类的东西。</p><h2 id="单测问题"><a href="#单测问题" class="headerlink" title="单测问题"></a>单测问题</h2><p>单测是保证工程质量的第一道重要防线。单测问题一般包括： </p><ul><li>单测未全部通过； </li><li>重要业务逻辑缺乏单测； </li><li>缺乏异常单测； </li><li>代码变更或BUG修复缺乏单测。</li></ul><p>单测全部通过应当是提交代码到代码库以及代码Review的前提条件。代码提交者应当保证单测全部通过。没有捷径可走。仅当单测全部通过才提交到代码库， 可以通过工具自动化实现。 对于 maven 管理的工程， 只需一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test &amp;&amp; git push origin branch_name 。</span><br></pre></td></tr></table></figure></p><p>单测应当更注重质，而非单纯追求覆盖率。</p><p>缺乏单测的重要业务逻辑就像裸露在空气中的电线一样，虽然能跑起来，却是很容易“触电”的。 方法： 增加覆盖比较全面的单测。</p><p>缺乏异常单测也是代码提交者常忽略的问题。 异常也是一种实际的业务场景，反映系统的健壮性和友好性。异常应该有相应的单元测试覆盖。创建条件使之抛出异常，并判断异常是否是指定异常；若没有抛出异常或者不是指定异常，则应该 AssertFailed 而不是通过。</p><p>对于代码变更和BUG修复，如果当时由于时间紧而没有写，后续应当补上。对于每个代码变更和BUG，都可以抽离出相应的代码部分， 并有相应单测覆盖，并注明原因。</p><h2 id="与原有业务逻辑不兼容"><a href="#与原有业务逻辑不兼容" class="headerlink" title="与原有业务逻辑不兼容"></a>与原有业务逻辑不兼容</h2><p>改动针对当前需求是合理的，却与原有业务逻辑不兼容，也是常见的问题。比如增加一个搜索条件， 却不能与原有条件联合查询。</p><p>与原有业务不兼容， 一般出现在：</p><p>一对一与一对多的变化。 比如原来的关系是一个订单对应一个物流信息， 后来变化为一个订单可能对应多个物流信息； 原来的逻辑是一个订单显示多个物流信息可以更改，后来要求一个订单只展示最近一次的物流信息可以修改。<br>多个业务组合。 业务 A 与业务 B 原来是分开发展的， 后来开展一种活动，将业务A与业务B进行一种组合营销。 此时，多半会出现很多 if-else 语句。</p><p>业务逻辑的兼容问题一般体现在系统的复用性和可扩展机制上。良好的系统可复用性和可扩展性可以更容易地做到业务逻辑兼容。 主要有如下几种级别：</p><p>自动兼容。 增加一种类型， 只是 biz_type 的值多了一种， 系统自动将已有功能适配给新的 biz_type；<br>一点改动。增加一个分支语句， 对 biz_type 的某个特性进行扩展；<br>一些改动。 需要见缝插针地增加一个单独的分支判断和逻辑处理模块， 对整体可扩展性没有影响， 但会造成局部的复杂化；<br>一部分功能改动。 只需要对其中一个功能模块做个扩展；<br>多处改动。 需要对多个功能模块做相应的改造，不过更多是新增而不是修改；<br>难以改动。 需要深入到功能模块内部做艰难的修改， 并要保证原有功能不受影响。</p><p>如何应对呢？</p><p>针对关联关系， 在项目之初， 可以询问清楚： 将来在产品上是否有可扩展的变化？ 及早预留空间， 或者确定产品上的对策； 在代码实现上， 兼顾考虑一对一到一对多，或一对多到一对一的关联变化。比如使用列表来表达单个信息， 使用索引从列表中获取单个信息。<br>针对业务组合， 明确各业务的核心部分， 抽离出业务的可复用的部分，形成 API ； 考虑组合模式和装饰器模式来进行扩展。</p><p>核心不变， 外围定制化。</p><h2 id="缺乏必要日志"><a href="#缺乏必要日志" class="headerlink" title="缺乏必要日志"></a>缺乏必要日志</h2><p>对于重要而关键的实例状态、代码路径及API调用，应当添加适当的INFO日志；对于异常，应当捕获并添加Error日志。缺乏日志并不会影响业务功能，但出现问题排查时，就会非常不方便，甚至错失极宝贵的机会(不易重现的情况尤其如此)。此外，缺乏日志也会导致可控性差，难以做数据统计和分析。</p><h2 id="错误码不符合规范"><a href="#错误码不符合规范" class="headerlink" title="错误码不符合规范"></a>错误码不符合规范</h2><p>错误码本身不算是代码问题，不过基于整个组织和工程的可维护性来说，可以将错误码不符合规范作为一种错误加以避免。方法： 对错误码进行可控的管理和遵循规范使用。可以使用公共文档维护， 也可以开发错误码管理系统来避免相同的错误码。</p><h2 id="参数检测缺乏或不足"><a href="#参数检测缺乏或不足" class="headerlink" title="参数检测缺乏或不足"></a>参数检测缺乏或不足</h2><p>参数检测是对业务处理的第一层重要过滤。如果参数检测不足够，就会导致脏数据进入服务处理，轻则导致异常，重则插入脏数据到数据库，对后续维护都会造成很多维护成本。方法： 采用“契约式编程”，规定前置条件，并使用单测进行覆盖。</p><p>对于复杂的业务应用， 优雅的参数检测处理尤为重要。 根据 “集中管理和处理一致性原则”， 可以建立一个 paramchecker 包， 设计一个可复用的微框架来对应用中所有的参数进行统一集中化检测。参数检测主要包括： (1) 参数的值类型， 可以根据不同值类型做基础的检测； (2) 参数的业务类型， 有基础非业务参数， 基础业务参数和具体业务参数。 不同的参数业务类型有不同的处理。 将参数值类型与参数业务类型结合起来， 结合一致性的异常捕获处理， 就可以实现一个可复用的参数检测框架。参数检测既可以采用普通的分支语句，也可以采用注解方式。采用注解方式更可读，不过单测编写更具技巧。</p><h2 id="引用错误"><a href="#引用错误" class="headerlink" title="引用错误"></a>引用错误</h2><p>对于动态语言， 由于缺乏强大的静态代码检测，修改了类引用的地方尤其要注意，很可能导致依赖的其他业务出错； 尤其是修改重名引用时。有线上故障教训。PHP工程中含有两个 Format 类， 一个基础的一个业务相关的， 被改动的类文件里开始没有指明引用，默认采用了基础 Format 类的实现， 然后提交者在改动文件头增加了对业务 Format 的引用， 导致依赖于基础Format类的其他业务不能正常工作。避免引用错误的方法： 当要在文件里增加新的类引用时， 先在文件里搜索是否有重名类的引用。如果有， 就要格外小心了。</p><h2 id="细节错误"><a href="#细节错误" class="headerlink" title="细节错误"></a>细节错误</h2><p>比如数组越界、JSON解析出错、函数参数传递出错、API 版本不对、使用网上拷贝的未经测试的代码、不成熟的算法、传值与传引用、相等性比较等。</p><p>对于数组越界错误， 通常要对空数组、针对数组大小的边界值+1和-1写单测来避免； 使用网上拷贝的代码，诚然可节省时间，也一定要加工一下并用单测覆盖； 传值和传引用可通过单测来避免错误； 对象的相等性比较切忌使用等号=。</p><h2 id="多重条件"><a href="#多重条件" class="headerlink" title="多重条件"></a>多重条件</h2><p>类似 if ((!A || !B) &amp;&amp; C || (D &amp;&amp; E)) 的多重条件要仔细推敲。方法： 最好拆分成多个有含义变量。 isNotDelay = !A || !B ; isNormal = C ; isAllow = D &amp;&amp; E ; cond = isNotDelay &amp;&amp; isNormal || isAllow 。</p><h2 id="文不符实"><a href="#文不符实" class="headerlink" title="文不符实"></a>文不符实</h2><p>文不符实是一种可能导致线上故障的错误。比如一个 getXXX 的函数，结果里面还做了 add, update 的操作。对问题排查、产品运维等都有非常大的杀伤力。因此命名一定要用实质内容相符，除非是故意搞破坏。</p><h2 id="跨语言或跨系统交互"><a href="#跨语言或跨系统交互" class="headerlink" title="跨语言或跨系统交互"></a>跨语言或跨系统交互</h2><p>稍具规模的互联网创业公司通常会采用多语言开发，比如PHP作为前端，Java作为后台服务。当动态类型语言与静态类型语言交互时，会有一些问题产生。比如PHP的对象通常是一个Map, 如果是空对象就会写成 [], 然而 [] 会被 Java 解析成列表。这样， 如果数据库的值是通过 PHP 写入，那么这个值既有可能是JSON对象字符串，也可能是空数组字符串， Java 来解析就有点尴尬了。 同样，当 Java 调用 PHP 接口时， 不规范的PHP接口既可能返回列表，也可能返回 true or false ， Java 解析返回结果也会比较尴尬。 因此， 在跨语言交互的边界处，要特别注意这些类型转换的差异。</p><p>跨系统交互则主要是接口设计与约定的问题。同一个项目里不同业务团队之间的业务接口设计与约定， 不同企业里开放接口的设计与约定， 要在最初深思熟虑，一旦开放，在后期很少有接口设计改动的空间。开放接口设计要符合小而美、正交的特性， 命名要贴切一致， 参数取值要指明约束，枚举参数要给出列表， 结果返回要规范一致，可以采用通用的 {“code”:200, “msg”: “success”, “data”: xxx} 。跨系统交互也要统一对术语和接口的理解的一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路线图&quot;&gt;&lt;a href=&quot;#路线图&quot; class=&quot;headerlink&quot; title=&quot;路线图&quot;&gt;&lt;/a&gt;路线图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/codereview-problem.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;常见代码
      
    
    </summary>
    
      <category term="研发管理" scheme="http://wushuning.com/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="笔记" scheme="http://wushuning.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="研发管理" scheme="http://wushuning.com/tags/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MAC破解安装IntelliJ IDEA方法</title>
    <link href="http://wushuning.com/2018/01/11/MAC%E7%A0%B4%E8%A7%A3%E5%AE%89%E8%A3%85IntelliJ-IDEA%E6%96%B9%E6%B3%95/"/>
    <id>http://wushuning.com/2018/01/11/MAC破解安装IntelliJ-IDEA方法/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2018-10-18T15:35:58.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC下破解安装Intellij-IDEA-2017-方法"><a href="#MAC下破解安装Intellij-IDEA-2017-方法" class="headerlink" title="MAC下破解安装Intellij IDEA 2017 方法"></a>MAC下破解安装Intellij IDEA 2017 方法</h1><p>破解的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IntelliJ IDEA 2017.3.2 (Ultimate Edition)  </span><br><span class="line">Build #IU-173.4127.27, built on December 26, 2017  </span><br><span class="line">Licensed to Rover12421 / Rover12421  </span><br><span class="line">You have a perpetual fallback license for this version  </span><br><span class="line">Subscription is active until December 31, 2099  </span><br><span class="line">JRE: 1.8.0_152-release-1024-b8 x86_64  </span><br><span class="line">JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o  </span><br><span class="line">Mac OS X 10.13.2</span><br></pre></td></tr></table></figure></p><h2 id="1、下载IntelliJ-IDEA-2017"><a href="#1、下载IntelliJ-IDEA-2017" class="headerlink" title="1、下载IntelliJ IDEA 2017"></a>1、下载IntelliJ IDEA 2017</h2><p><a href="https://www.jetbrains.com/idea/download/#section=mac" target="_blank" rel="noopener">IDEA官网下载无限制版</a><br><img src="/images/idea/ideadownload.jpg" width="60%"></p><h2 id="2、下载破解文件JetbrainsCrack-2-6-2-jar"><a href="#2、下载破解文件JetbrainsCrack-2-6-2-jar" class="headerlink" title="2、下载破解文件JetbrainsCrack-2.6.2.jar"></a>2、下载破解文件JetbrainsCrack-2.6.2.jar</h2><p><a href="http://idea.lanyus.com" target="_blank" rel="noopener">进入下载界面</a>  </p><p><img src="/images/idea/coderegist.png" width="60%"></p><h2 id="3、安装IntelliJ-IDEA-2017"><a href="#3、安装IntelliJ-IDEA-2017" class="headerlink" title="3、安装IntelliJ IDEA 2017"></a>3、安装IntelliJ IDEA 2017</h2><h2 id="4、安装后Applications文件夹中找到IDEA-右键show-package-contents找到bin目录下，将下载的破解文件拷贝到该目录下"><a href="#4、安装后Applications文件夹中找到IDEA-右键show-package-contents找到bin目录下，将下载的破解文件拷贝到该目录下" class="headerlink" title="4、安装后Applications文件夹中找到IDEA,右键show package contents找到bin目录下，将下载的破解文件拷贝到该目录下"></a>4、安装后Applications文件夹中找到IDEA,右键show package contents找到bin目录下，将下载的破解文件拷贝到该目录下</h2><p><img src="/images/idea/registaccess.png" width="60%"></p><h2 id="5、打开上图中的idea-vmoptions追加如下配置"><a href="#5、打开上图中的idea-vmoptions追加如下配置" class="headerlink" title="5、打开上图中的idea.vmoptions追加如下配置"></a>5、打开上图中的idea.vmoptions追加如下配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:/Applications/IntelliJ IDEA.app/Contents/bin/JetbrainsCrack-2.6.10-release-enc.jar</span><br></pre></td></tr></table></figure><h2 id="6、启动IDEA-提示需要注册，将获取的注册码填入"><a href="#6、启动IDEA-提示需要注册，将获取的注册码填入" class="headerlink" title="6、启动IDEA 提示需要注册，将获取的注册码填入"></a>6、启动IDEA 提示需要注册，将获取的注册码填入</h2><p>Help &gt; Register<br><img src="/images/idea/registin.png" width="60%"><br>选中Activation code 将注册码填入下面的输入框中即可<br><img src="/images/idea/registwindow.png" width="60%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MAC下破解安装Intellij-IDEA-2017-方法&quot;&gt;&lt;a href=&quot;#MAC下破解安装Intellij-IDEA-2017-方法&quot; class=&quot;headerlink&quot; title=&quot;MAC下破解安装Intellij IDEA 2017 方法&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="idea" scheme="http://wushuning.com/categories/idea/"/>
    
    
      <category term="idea" scheme="http://wushuning.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot无法启动，启动后报404错误</title>
    <link href="http://wushuning.com/2017/11/24/SpringBoot%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%EF%BC%8C%E5%90%AF%E5%8A%A8%E5%90%8E%E6%8A%A5404%E9%94%99%E8%AF%AF/"/>
    <id>http://wushuning.com/2017/11/24/SpringBoot无法启动，启动后报404错误/</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-10-18T15:20:02.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot无法启动"><a href="#SpringBoot无法启动" class="headerlink" title="SpringBoot无法启动"></a>SpringBoot无法启动</h1><p>可能的原因：直接将启动类放在了src.java.main下<br>解决方案：在main下创建自己的packadge<br>如:src.java.main.com.wzk.starter  </p><h1 id="SpringBoot正常启动，但是访问的时候提示404"><a href="#SpringBoot正常启动，但是访问的时候提示404" class="headerlink" title="SpringBoot正常启动，但是访问的时候提示404"></a>SpringBoot正常启动，但是访问的时候提示404</h1><p>原因是：controller没有被spring容器扫描到<br>解决方案1：spring boot默认扫描启动类的当前包和下级包<br>比如：启动类在 com.wzk.starter包下，那么spring 会扫描 com.wzk.starter和com.wzk.starter.*<br>如果编写的controller没有放置在这些位置就是报错</p><p>解决方案2：配置spring boot的扫描路径<br>在启动类上面添加注解：@ComponentScan(basePackages = {“com.wzk.*”})  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot无法启动&quot;&gt;&lt;a href=&quot;#SpringBoot无法启动&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot无法启动&quot;&gt;&lt;/a&gt;SpringBoot无法启动&lt;/h1&gt;&lt;p&gt;可能的原因：直接将启动类放在了src.jav
      
    
    </summary>
    
      <category term="springboot" scheme="http://wushuning.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://wushuning.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门环境搭建，maven构建，Intellij IDEA 2016.2</title>
    <link href="http://wushuning.com/2017/11/24/SpringBoot%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%8Cmaven%E6%9E%84%E5%BB%BA%EF%BC%8CIntellij-IDEA-2016-2/"/>
    <id>http://wushuning.com/2017/11/24/SpringBoot入门环境搭建，maven构建，Intellij-IDEA-2016-2/</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-10-18T15:37:58.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intellij-IDEA工具下搭建SpringBoot入门程序使用maven"><a href="#Intellij-IDEA工具下搭建SpringBoot入门程序使用maven" class="headerlink" title="Intellij IDEA工具下搭建SpringBoot入门程序使用maven"></a>Intellij IDEA工具下搭建SpringBoot入门程序使用maven</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Intellij IDEA 2016.2  </li><li>maven 3.0.5  </li><li>SpringBoot 1.5.8  </li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="一、新建项目"><a href="#一、新建项目" class="headerlink" title="一、新建项目"></a>一、新建项目</h3><p>file-&gt;new-&gt;project<br>创建项目选择maven如下图<br><img src="/images/springboot/springboot-new-1.jpeg" alt=""><br>点击next<br>如图填入自己项目的信息，由于是创建的maven项目，所以此处填写maven需要的字段信息，具体见途中说明<br><img src="/images/springboot/springboot-new-2.jpeg" alt=""><br>点击next<br>这一步填写项目的名称和存储的路径<br><img src="/images/springboot/springboot-new-3.jpeg" alt=""><br>点击finish创建成功<br>到这一步一个简单的maven工程就创建完成了。</p><h3 id="二、添加springboot支持"><a href="#二、添加springboot支持" class="headerlink" title="二、添加springboot支持"></a>二、添加springboot支持</h3><p>pom.xml文件中增加配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>由于最终要打包成jar格式所以pom.xml中还需增加配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wzk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring02<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>注意:<packaging>jar</packaging>参数的值为:jar</p><h3 id="三、编写测试代码"><a href="#三、编写测试代码" class="headerlink" title="三、编写测试代码"></a>三、编写测试代码</h3><p>创建类如下，SpringBoot的启动类，如果不做任何配置，默认启动的容器是tomcat<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wzk.ms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再写一个自己的controller类，输入经典的helloworld<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wzk.ms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String test = <span class="string">"Hello"</span>;</span><br><span class="line">        String test1 = <span class="string">" world"</span>;</span><br><span class="line">        String returnStr = test + test1;</span><br><span class="line">        <span class="keyword">return</span> returnStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、启动测试"><a href="#四、启动测试" class="headerlink" title="四、启动测试"></a>四、启动测试</h3><ul><li>SpringbootApplication是一个含有main方法的java程序，所以直接运行</li><li>浏览器输入<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a><br>因为默认是tomcat所以端口默认8080，返回Hello world.</li></ul><h3 id="五、配置"><a href="#五、配置" class="headerlink" title="五、配置"></a>五、配置</h3><p>修改springboot的配置很简单，直接修改resource下的application.properties文件即可。<br>如修改访问端口为8081，添加配置<br>server.port=8081</p><p>tomcat的其他配置可以参考<br>server.port=8081<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#server.address= # bind to a specific NIC</span><br><span class="line">#server.session-timeout= # session timeout in seconds</span><br><span class="line">#the context path, defaults to &apos;/&apos;</span><br><span class="line">#server.context-path=/spring-boot</span><br><span class="line">#server.servlet-path= # the servlet path, defaults to &apos;/&apos;</span><br><span class="line">#server.tomcat.access-log-pattern= # log pattern of the access log</span><br><span class="line">#server.tomcat.access-log-enabled=false # is access logging enabled</span><br><span class="line">#server.tomcat.protocol-header=x-forwarded-proto # ssl forward headers</span><br><span class="line">#server.tomcat.remote-ip-header=x-forwarded-for</span><br><span class="line">#server.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)</span><br><span class="line">#server.tomcat.background-processor-delay=30; # in seconds</span><br><span class="line">#server.tomcat.max-threads = 0 # number of threads in protocol handler</span><br><span class="line">#server.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding</span><br></pre></td></tr></table></figure></p><h3 id="六、打包成jar"><a href="#六、打包成jar" class="headerlink" title="六、打包成jar"></a>六、打包成jar</h3><p>打包成可运行的jar<br>intelliJ打开命令行，运行mvn clean package即可<br>默认输出到target目录下，然后输入java -jar xxx.jar即可启动<br>关闭命令行窗口即关闭了容器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Intellij-IDEA工具下搭建SpringBoot入门程序使用maven&quot;&gt;&lt;a href=&quot;#Intellij-IDEA工具下搭建SpringBoot入门程序使用maven&quot; class=&quot;headerlink&quot; title=&quot;Intellij IDEA工
      
    
    </summary>
    
      <category term="springboot" scheme="http://wushuning.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://wushuning.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Java性能调优的11个实用技巧</title>
    <link href="http://wushuning.com/2017/11/24/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%8411%E4%B8%AA%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://wushuning.com/2017/11/24/Java性能调优的11个实用技巧/</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-10-18T15:26:52.084Z</updated>
    
    <content type="html"><![CDATA[<p>作者：ITeye<br>来源：ITeye[<a href="http://www.iteye.com/news/32754]" target="_blank" rel="noopener">http://www.iteye.com/news/32754]</a></p><p>大多数开发人员认为性能优化是个比较复杂的问题，需要大量的经验和知识。是的，这并不没有错。诚然，优化应用程序以获得最好的性能并不是一件容易的事情，但这并不意味着你在没有获得这些经验和知识之前就不能做任何事。下面有几个很容易遵循的建议和最佳实践能够帮你创建一个性能良好的应用程序。</p><p>这些建议中的大多数都是基于Java的，但是也不一定，也有一些是可以应用于所有的应用程序和编程语言的。在我们分享基于Java的性能调优技巧之前，让我们先讨论一下这些通用的性能调优技巧。</p><h3 id="1-在必要之前，先不要优化"><a href="#1-在必要之前，先不要优化" class="headerlink" title="1.在必要之前，先不要优化"></a>1.在必要之前，先不要优化</h3><p>这可能是最最重要的性能调优技巧之一。你应该遵循常见的最佳实践，并尝试有效地实现你的用例。但这并不意味着在证明它是必要之前，替换任何标准库或构建复杂的优化。</p><p>在大多数情况下，过早的优化占用了大量的时间，使得代码难以读取和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费了大量时间来优化应用程序的非关键部分。</p><p>那么，你如何证明你需要优化某些东西呢?</p><p>首先，你需要确定应用程序代码的速度，例如，为所有API调用指定一个最大响应时间，或者指定在特定时间范围内导入的记录数量。完成之后，你可以度量应用程序的哪些部分太慢而需要改进。当这样做之后，那么请继续看第二个调优技巧。</p><h3 id="2-使用分析器来找到真正的瓶颈"><a href="#2-使用分析器来找到真正的瓶颈" class="headerlink" title="2.使用分析器来找到真正的瓶颈"></a>2.使用分析器来找到真正的瓶颈</h3><p>在你遵循第一条建议，并确定你的应用程序的某些部分的确需要改进之后，问自己从哪里开始?</p><p>你可以用两种方法来解决这个问题:</p><p>你可以看一下你的代码，从看起来可疑或者你觉得它可能会产生问题的部分开始。<br>或者使用分析器，获取代码中每个部分的行为和性能的详细信息。<br>至于为什么应该总是遵循第二种方法。</p><p>答案应该很明显，基于分析器的方法能让你更好地理解代码的性能含义，并允许你关注最关键的部分。如果你曾经使用过分析器，你将会惊讶于代码的哪些部分造成了性能问题。然而，很多时候，你的第一次猜想会把你引向错误的方向。</p><h3 id="3-为整个应用程序创建性能测试套件"><a href="#3-为整个应用程序创建性能测试套件" class="headerlink" title="3 .为整个应用程序创建性能测试套件"></a>3 .为整个应用程序创建性能测试套件</h3><p>这是另一个帮助你避免许多意想不到问题的一般技巧，这些问题通常发生在性能改进部署到生产环境之后。你应该经常定义测试整个应用程序的性能测试套件，并在你完成性能改进之前和之后运行它。</p><p>这些额外的测试运行将帮助你识别更改的功能和性能方面的影响，并确保你不会发布一个弊大于利的更新。如果你的任务运行于应用程序的多个不同部分比如数据库或缓存，这一点尤其重要。</p><h3 id="4-首先解决最大的瓶颈问题"><a href="#4-首先解决最大的瓶颈问题" class="headerlink" title="4.首先解决最大的瓶颈问题"></a>4.首先解决最大的瓶颈问题</h3><p>在创建了测试套件并使用分析器对应用程序进行分析之后，你就有了一个需要提高性能的问题列表，这很好，但它仍然不能回答你应该从哪里开始的问题。你可以从那些可以快速搞定的开始，亦或者从最重要的问题开始。</p><p>当然前者很诱人，因为这很快就能出结果。有时，可能需要说服其他团队成员或你的管理层，性能分析是值得的。</p><p>但总的来说，我建议首先着手处理最重要的性能问题。这将为你提供最大的性能改进，而且你可能只需要修复这些问题中的几个就可以解决你的性能需求。</p><p>在了解通用性能调优技巧之后，让我们再来仔细看看一些特定于Java的调优技巧。</p><h3 id="5-使用StringBuilder以编程方式连接字符串"><a href="#5-使用StringBuilder以编程方式连接字符串" class="headerlink" title="5.使用StringBuilder以编程方式连接字符串"></a>5.使用StringBuilder以编程方式连接字符串</h3><p>在Java中有许多不同的连接字符串的选项。例如，可以使用一个简单的+或+ =、老的StringBuffer或StringBuilder。</p><p>那么，你应该选择哪种方法呢?</p><p>答案取决于连接字符串的代码。如果你以编程方式向字符串中添加新内容，例如，在for循环中，你应该使用StringBuilder。它比StringBuffer更容易使用和提供更好的性能。但是请记住，StringBuilder与StringBuffer不同，它不是线程安全的，而且可能不适合所有用例。</p><p>你只需要实例化一个新的StringBuilder，并调用append方法在字符串中添加一个新的部分。当你添加了所有的部分后，可以调用toString()方法来检索连接字符串。</p><p>下面的代码片段展示了一个简单的示例。在每次迭代过程中，这个循环将i转换成一个字符串，并将其添加到StringBuilder sb的空间中，因此到最后，这段代码写入“this is test0123456789”到日志文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(“This is a test”);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;  </span><br><span class="line">    sb.append(i);  </span><br><span class="line">    sb.append(” “);  </span><br><span class="line">&#125;  </span><br><span class="line">log.info(sb.toString());</span><br></pre></td></tr></table></figure><p>正如在代码片段中看到的，你可以为构造函数方法提供字符串的第一个元素。这将创建一个新的StringBuilder，其中包含提供的字符串和16个额外字符的容量。当你向StringBuilder中添加更多字符时，JVM将动态地改变StringBuilder的大小。</p><p>如果你已经知道自己的字符串包含多少字符，那么你可以向不同的构造函数方法提供这个数字，以实例化一个具有被定义容量的StringBuilder。这进一步提高了它的效率，因为它不需要动态扩展它的容量。</p><h3 id="6-在声明中使用-连接字符串"><a href="#6-在声明中使用-连接字符串" class="headerlink" title="6.在声明中使用+连接字符串"></a>6.在声明中使用+连接字符串</h3><p>当你在Java中实现第一个应用程序时，可能有人告诉你不应该用＋来连接字符串。如果在应用程序逻辑中连接字符串这是正确的。字符串是不可变的，每个字符串连接的结果存储在一个新的字符串对象中。这需要额外的内存，并降低应用程序的速度，特别是在循环中连接多个字符串时。</p><p>在这些情况下，你应该遵循tip 5并使用StringBuilder。</p><p>但如果你只是将一个字符串分解成多行来提高代码的可读性，那就不是这样了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ”  </span><br><span class="line">+ “FROM Author a ”  </span><br><span class="line">+ “WHERE a.id = :id”);</span><br></pre></td></tr></table></figure><p>在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器将优化它并在编译时执行连接。因此，在运行时，代码只使用1个字符，不需要连接。</p><h3 id="7-尽可能使用基本数据类型"><a href="#7-尽可能使用基本数据类型" class="headerlink" title="7.尽可能使用基本数据类型"></a>7.尽可能使用基本数据类型</h3><p>另一种避免开销，提高应用程序性能的快速方法就是使用原始数据类型而不是它们的包装类。因此，最好是使用int而不是Integer，或者是double而不是Double。这将让JVM将值存储在堆栈中，以减少内存消耗，并更有效地处理它。</p><h3 id="8-尽量避免BigInteger和BigDecimal"><a href="#8-尽量避免BigInteger和BigDecimal" class="headerlink" title="8.尽量避免BigInteger和BigDecimal"></a>8.尽量避免BigInteger和BigDecimal</h3><p>由于我们已经讨论了数据类型，我们再来看下BigInteger和BigDecimal。尤其是后者，由于其精度高而受欢迎。但这是有代价的。<br>BigInteger和BigDecimal比简单的long或double需要更多的内存，并且大大降低所有的计算速度。因此，如果你需要额外的精度，或者你的数字超过了一个long范围，最好三思而后行。这可能是你在提升性能问题中唯一需要更改的地方，特别是当你正在实现一个数学算法。</p><h3 id="9-首先检查当前日志级别"><a href="#9-首先检查当前日志级别" class="headerlink" title="9.首先检查当前日志级别"></a>9.首先检查当前日志级别</h3><p>这个建议是显而易见的，但不幸的是，你会发现许多代码忽略它。在创建调试消息之前，应该先检查当前日志级别。</p><p>这里有两个例子来说明你不应该这样做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// don’t do this  </span></span><br><span class="line">log.debug(“User [” + userName + “] called method X with [” + i + “]”);  </span><br><span class="line"><span class="comment">// or this  </span></span><br><span class="line">log.debug(String.format(“User [%s] called method X with [%d]”, userName, i));</span><br></pre></td></tr></table></figure><p>在这两种情况下，你将执行所有需要的步骤来创建日志消息，而不知道日志框架是否使用日志消息。在创建调试消息之前，最好先检查当前日志级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do this  </span></span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;  </span><br><span class="line">    log.debug(“User [” + userName + “] called method X with [” + i + “]”);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-使用Apache-Commons-StringUtils-Replace-代替String-replace"><a href="#10-使用Apache-Commons-StringUtils-Replace-代替String-replace" class="headerlink" title="10.使用Apache Commons StringUtils.Replace 代替String.replace"></a>10.使用Apache Commons StringUtils.Replace 代替String.replace</h3><p>一般来说,String.replace 方法工作得很好，而且非常高效，特别是如果你使用的是Java 9。但是，如果应用程序需要大量的替换操作，并且你还没有更新到最新的Java版本，那么检查更快和更有效的替代方案仍然是有意义的。</p><p>一个候选就是 Apache Commons Lang’s StringUtils.replace 方法。正如Lukas Eder在他最近的一篇博客文章中所描述的那样，它大大超过了Java 8的String.replace 方法。</p><p>它只需要很小的改变。你只需要为Apache’s Commons Lang 项目增加一个Maven依赖项到你的应用pom.xml，并用StringUtils.replace方法替换所有String.replace方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replace this  </span></span><br><span class="line">test.replace(“test”, “simple test”);  </span><br><span class="line"><span class="comment">// with this  </span></span><br><span class="line">StringUtils.replace(test, “test”, “simple test”);</span><br></pre></td></tr></table></figure><h3 id="11-缓存昂贵的资源，比如数据库连接"><a href="#11-缓存昂贵的资源，比如数据库连接" class="headerlink" title="11.缓存昂贵的资源，比如数据库连接"></a>11.缓存昂贵的资源，比如数据库连接</h3><p>缓存是一种流行的解决方案来避免重复执行昂贵或频繁使用的代码片段。一般的想法很简单:重复使用这些资源比一次又一次地创建一个新的资源要便宜得多。</p><p>一个典型的例子就是在池中缓存数据库连接。创建新连接需要时间，如果重用现有连接，则可以避免。</p><p>还可以在Java语言本身中找到其他示例。例如，Integer类的valueOf方法缓存了- 128和127之间的值。你可能会说，创建一个新整数并不太贵，但它经常使用，缓存最常用的值提供了性能方面的好处。</p><p>但当你考虑缓存时，请记住，缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此可能需要管理你的缓存，以使资源能够访问或删除过时的资源。</p><p>因此，在你开始缓存任何资源之前，请确保是经常使用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正如你所看到的，提高应用程序的性能有时不需要做大量的工作。这篇文章中的大多数建议，其实只需要稍微的努力就可以将它们应用到代码中。</p><p>但通常最重要的建议是很编程语言无关的:</p><ul><li>在你知道有必要之前，不要优化</li><li>使用分析器来找到真正的瓶颈</li><li>首先解决最大的瓶颈问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者：ITeye&lt;br&gt;来源：ITeye[&lt;a href=&quot;http://www.iteye.com/news/32754]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.iteye.com/news/32754]&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://wushuning.com/categories/java/"/>
    
    
      <category term="java性能" scheme="http://wushuning.com/tags/java%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>猫-森林-纪念</title>
    <link href="http://wushuning.com/2017/10/26/%E7%BA%AA%E5%BF%B5%E7%88%B1%E7%8C%AB%E6%A3%AE%E6%9E%97/"/>
    <id>http://wushuning.com/2017/10/26/纪念爱猫森林/</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2018-10-18T15:18:39.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2015-4-18号"><a href="#2015-4-18号" class="headerlink" title="2015-4-18号"></a>2015-4-18号</h1><p><img src="/images/senlin/senlin-1-start.jpeg" alt="森林"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2015-4-18号&quot;&gt;&lt;a href=&quot;#2015-4-18号&quot; class=&quot;headerlink&quot; title=&quot;2015-4-18号&quot;&gt;&lt;/a&gt;2015-4-18号&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/senlin/senlin-1-star
      
    
    </summary>
    
      <category term="人生" scheme="http://wushuning.com/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://wushuning.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-极简笔记-6大设计原则</title>
    <link href="http://wushuning.com/2017/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%81%E7%AE%80%E7%AC%94%E8%AE%B0-6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://wushuning.com/2017/10/13/设计模式-极简笔记-6大设计原则/</id>
    <published>2017-10-12T16:00:00.000Z</published>
    <updated>2018-10-18T15:16:19.155Z</updated>
    
    <content type="html"><![CDATA[<p>通过尽量少的语言描述设计模式的相关概念<br>如果想要更详细的描述可参看设计模式其他相关书籍或者资料</p><h1 id="6大设计原则"><a href="#6大设计原则" class="headerlink" title="6大设计原则"></a>6大设计原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>英文名称：Single Responsibiity Principle 简称：SRP<br>定义：在定义接口的时候，接口的功能要单一。<br>该原则素来有很多的争议，因为这个原则在实际开发过程中很难界定功能范围，所以需要根据实际情况使用，不要生搬硬套。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>英文名称：Liskov Substitution Principle 简称：LSP<br>通俗定义：只要父类能出现的地方子类就可以出现，而且替换为子类不会产生任何错误或异常<br>该原则主要为继承定义一个规范，子类尽量不要出现父类不存在的方法或属性</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>英文名称：Dependence Inversion Principle 简称：DIP<br>通俗定义：通常依赖都是指的具体实现类的依赖和耦合，这里倒置就是要把依赖放到接口层。具体的实现类之间不存在依赖，实现类只是依赖他们的接口。<br>该原则就是经常谈到的面向接口编程</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>英文名称：Interface Segregation Principle 简称：ISP<br>通俗定义：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。<br>该原则规范了我们对外提供接口时的一个规范，对外提供接口时，只提供需要的接口。<br>比如：提供通过姓名查询用户信息的接口，就提供queryByName(String name),而不是提供一个通用query(String queryParam)，约定参数为{“name”:张三}这样的形式。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>英文名称：Law of Demeter 简称：LOD<br>或<br>英文名称：Least Knowledge Principle 简称：LKP<br>本人喜欢第二个描述。<br>通俗定义：一个类再调用其他类或者接口的时候应该对该类有最少的了解，只要知道该接口能实现什么功能即可，至于如何实现，以及过程都不需要关心。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>英文名称：Open Closed Principle 简称：OCP<br>通俗定义：一个接口，类，模块的定义应该对扩展开放，对修改关闭<br>该原则规范我们在开发过程中尽量通过扩展的方式来实现新的功能或者变化，而不是去修改原有逻辑或者接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过尽量少的语言描述设计模式的相关概念&lt;br&gt;如果想要更详细的描述可参看设计模式其他相关书籍或者资料&lt;/p&gt;
&lt;h1 id=&quot;6大设计原则&quot;&gt;&lt;a href=&quot;#6大设计原则&quot; class=&quot;headerlink&quot; title=&quot;6大设计原则&quot;&gt;&lt;/a&gt;6大设计原则&lt;/h1
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wushuning.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wushuning.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>子类与父类,向上转型与向下转型</title>
    <link href="http://wushuning.com/2017/10/12/%E5%AD%90%E7%B1%BB%E4%B8%8E%E7%88%B6%E7%B1%BB-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B8%8E%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    <id>http://wushuning.com/2017/10/12/子类与父类-向上转型与向下转型/</id>
    <published>2017-10-11T16:00:00.000Z</published>
    <updated>2018-10-18T15:38:31.741Z</updated>
    
    <content type="html"><![CDATA[<p>作者：本人<br>来源：原创</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>向上转型：子类赋给父类<br>向下转型：父类赋给子类（必须是父引用本身已经指向子类对象的情况，并且要加子类强制转换，否则报错）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name = <span class="string">"父类"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"名字："</span>+name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name = <span class="string">"子类"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"名字："</span>+name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Class Test&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Super <span class="keyword">super</span> = <span class="keyword">new</span> Sub();<span class="comment">//向上转型</span></span><br><span class="line">    Sub sub  = (Sub)<span class="keyword">super</span>;<span class="comment">//向下转型，且super指向子类对象</span></span><br><span class="line">    <span class="comment">//注属性不会覆写，super是父类型引用所以指向的属性是父类型属性</span></span><br><span class="line">    <span class="keyword">super</span>.MyName();<span class="comment">//输出：名字：父类</span></span><br><span class="line">    sub.MyName();<span class="comment">//输出：名字：子类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//super_1指向的是父类型，强制转换的时候出错</span></span><br><span class="line">    Super super_1 = <span class="keyword">new</span> Super();</span><br><span class="line">    Sub sub_1 = (Sub)super_1;<span class="comment">//编译错误，ClassCaseException</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者：本人&lt;br&gt;来源：原创&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;向上转型：子类赋给父类&lt;br&gt;向下转型：父类赋给子类（必须是父引用本身已经指向子类对象的情况，并
      
    
    </summary>
    
      <category term="java" scheme="http://wushuning.com/categories/java/"/>
    
    
      <category term="java" scheme="http://wushuning.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员跑了几千公里到戈壁徒步70KM完--感悟</title>
    <link href="http://wushuning.com/2017/10/10/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%91%E4%BA%86%E5%87%A0%E5%8D%83%E5%85%AC%E9%87%8C%E5%88%B0%E6%88%88%E5%A3%81%E5%BE%92%E6%AD%A570KM-%E5%AE%8C/"/>
    <id>http://wushuning.com/2017/10/10/一个程序员跑了几千公里到戈壁徒步70KM-完/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2018-10-18T15:23:58.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从五月份的医疗行业沙漠徒步挑战赛到10.1的戈壁挑战赛<br>跟随一个初创团队，感受创业过程感悟颇多<br>作为组委会裁判，IT中心负责人，中控台操盘手…<br>很遗憾，以后应该不会再继续参与了，具体原因不想缀述。<br>到可以用一个小寓言表达：一个水桶能装多少水是由最短那跟木板决定的。</p><p>创业真的需要：一个灵魂人物+靠谱的团队+能力的均等<br>创业不是救助，没人可怜你，没人教你，所有东西都要自己悟。创业也不是小孩过家家，专业是唯一标准<br>也多少明白了华为事件：“辞退你与能力无关”。</p><h1 id="感悟-态度"><a href="#感悟-态度" class="headerlink" title="感悟-态度"></a>感悟-态度</h1><p>态度是，一个靠谱的人永远比一个有能力缺不靠谱的人受欢迎。</p><h1 id="感悟-情商"><a href="#感悟-情商" class="headerlink" title="感悟-情商"></a>感悟-情商</h1><p>听很重要，听别人说了什么，听别人没说什么，听自己想说什么，听自己说正确了多少。<br>说很重要，说要看场合，看人，看场景，要思而后说，很多人讲话不经过大脑。<br>悟很重要，交流是一门艺术，多思多想多悟，想不明白就闭嘴少说话。言多必失。</p><h1 id="感悟-信仰"><a href="#感悟-信仰" class="headerlink" title="感悟-信仰"></a>感悟-信仰</h1><p>很多人都说中国人没有信仰，不能全否定，但至少绝大多数是没有的<br>人一定要有信仰，信仰决定你对人生的态度，决定你的朋友圈，以及你的家庭<br>人要有自己坚持的东西。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>要加入比自己优秀的圈子，这样你才能更优秀，至少不能比自己差<br>要加入比自己聪明的圈子，这样你能更聪明，至少不能比自己笨<br>要加入与自己情商匹配或更高的圈子，与这些人共事是一种享受<br>当你发现自己开始于身边的人格格不入的时候就要好好想想，是自己退步了，还是已经超越了大部分人<br>如果是前者毫无疑问赶紧追上，如果是后者，则需要考虑继续往上一个阶层，或者换个环境。比你优秀的人<br>很多，要善于发现，不要在比你差的人身上耗费太多精力，否则你只会跟他一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;从五月份的医疗行业沙漠徒步挑战赛到10.1的戈壁挑战赛&lt;br&gt;跟随一个初创团队，感受创业过程感悟颇多&lt;br&gt;作为组委会裁判，IT中心负责人，
      
    
    </summary>
    
      <category term="人生" scheme="http://wushuning.com/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://wushuning.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员跑了几千公里到戈壁徒步70KM</title>
    <link href="http://wushuning.com/2017/10/04/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%91%E4%BA%86%E5%87%A0%E5%8D%83%E5%85%AC%E9%87%8C%E5%88%B0%E6%88%88%E5%A3%81%E5%BE%92%E6%AD%A570KM/"/>
    <id>http://wushuning.com/2017/10/04/一个程序员跑了几千公里到戈壁徒步70KM/</id>
    <published>2017-10-03T16:00:00.000Z</published>
    <updated>2018-10-18T15:13:47.873Z</updated>
    
    <content type="html"><![CDATA[<p>10月5日-10月7日，三天70+km徒步，敦煌，戈壁。从北京-到敦煌</p><p>这一串描述很难跟一个程序员想到一起，有时候自己想来也很疯狂。</p><p>慢慢的发现自己有些改变，不太发微信状态，不发微博，不看qq</p><p>更多的是看看书，看看新闻，看看网上分享的技术文档，上知乎，csdn回答一些技术问题</p><p>闲暇时间开始重新写一写东西。</p><p>生活中开始参与非IT相关的领域的活动</p><p>本人并非什么技术狂人，也不是编程技术的狂热爱好者，工作久了，也尝试拓宽自己的视角，接触不一样的人，不一样的事。</p><p>久了，也懂得了很多，比如情怀这个东西，我们知道锤子一直在玩情怀，我们提到锤子也总在说情怀，可是你懂情怀是什么吗？用情怀是一种什么感受？其实很遥远。</p><p>但是当你身边出现这么一群人，因为情怀，因为梦想去做一件事情的时候，这种感觉是没法形容的。很幸运我碰到了这么一位。也有幸参与其中一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;10月5日-10月7日，三天70+km徒步，敦煌，戈壁。从北京-到敦煌&lt;/p&gt;
&lt;p&gt;这一串描述很难跟一个程序员想到一起，有时候自己想来也很疯狂。&lt;/p&gt;
&lt;p&gt;慢慢的发现自己有些改变，不太发微信状态，不发微博，不看qq&lt;/p&gt;
&lt;p&gt;更多的是看看书，看看新闻，看看网上分享
      
    
    </summary>
    
      <category term="人生" scheme="http://wushuning.com/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://wushuning.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>mac中JDK安装配置</title>
    <link href="http://wushuning.com/2017/09/24/mac%E4%B8%ADJDK%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://wushuning.com/2017/09/24/mac中JDK安装配置/</id>
    <published>2017-09-23T16:00:00.000Z</published>
    <updated>2018-10-18T15:29:08.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统内置JDK"><a href="#系统内置JDK" class="headerlink" title="系统内置JDK"></a>系统内置JDK</h2><p>mac默认自带一个jdk6</p><h2 id="自定义安装JDK"><a href="#自定义安装JDK" class="headerlink" title="自定义安装JDK"></a>自定义安装JDK</h2><p>从oracle下载jdk安装后<br>默认安装路径如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p><p>并且系统内置的jdk会默认为最新安装的</p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>vi .bash_profile<br>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home</span><br><span class="line">export CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></p><h2 id="删除已经安装的jdk"><a href="#删除已经安装的jdk" class="headerlink" title="删除已经安装的jdk"></a>删除已经安装的jdk</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf jdk1.8.0_101.jdk</span><br></pre></td></tr></table></figure><p>可以进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/libexec</span><br><span class="line">java_home -V</span><br></pre></td></tr></table></figure></p><p>查看所有jdk的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统内置JDK&quot;&gt;&lt;a href=&quot;#系统内置JDK&quot; class=&quot;headerlink&quot; title=&quot;系统内置JDK&quot;&gt;&lt;/a&gt;系统内置JDK&lt;/h2&gt;&lt;p&gt;mac默认自带一个jdk6&lt;/p&gt;
&lt;h2 id=&quot;自定义安装JDK&quot;&gt;&lt;a href=&quot;#自定义安
      
    
    </summary>
    
      <category term="java" scheme="http://wushuning.com/categories/java/"/>
    
    
      <category term="java" scheme="http://wushuning.com/tags/java/"/>
    
      <category term="mac" scheme="http://wushuning.com/tags/mac/"/>
    
  </entry>
  
</feed>
